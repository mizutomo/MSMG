==============================
Ch.3 AMS Behavioral Modeling
==============================

Overview
====================================

* Analog設計者は、これまでボトムアップ手法により設計を行なってきた。
* 複数のサブシステムを含んだシミュレーションを行うとき、Trレベルでは時間がかかるため、一部ブロック(特性として見る必要のないブロック)をビヘイビアモデルに置き換えるなど、シミュレーションの高速化のためだけに機能モデルを使用してきた。


* このようなボトムアップアプローチは、対処療法的であり、プロジェクトの銀の弾丸ではない。


* システム設計段階から、モデルによりスペックの検証を行うトップダウン設計に移行する必要がある。


* トップダウン・アプローチを取ることで、Executable Spec(検証可能な仕様書)となる。


Modeling classifications
====================================

* アナログの場合、決まった抽象度というものがない。また、デジタルと異なり、モデル開発をサポートするようなツールもほとんどないため、モデル作成にかかる時間が千差万別となる。
* シミュレーション時間も、抽象度によって、大きく異る。
* 効率的なシミュレーションを行うためには、要求に応じた適切な抽象度・複雑度のモデルを用意する必要がある。


* モデリングする際には、以下のことを考慮する必要がある。

  * 対象としているシミュレータがAnalog/Digital/Mixed-Signalを扱えるかどうか。
  * 適切な階層(抽象)構造となっているか。
  * モデルにどこまでの特性を組み込むか。1次の線形特性か、非線形特性か。


* モデル化において重要なことは、モデルの使用目的を把握すること。
* モデルの使用目的が把握できていないと、無駄に抽象度の低いモデルを作ったりしてしまう。


Model Development
-----------------------------------

* モデルの複雑さは、どのレベルであっても要素の数に依存する。

  * もし、ブロックが巨大なピン数を持っていた場合、リーズナブルなレベルまでブレークダウンさせる。
  * ただし、これ以上機能として分割できないようなレベルにまで落とし込むのは、機能モデルとしては適切ではない。


Design Topological Considerations
-----------------------------------

* サブシステムへの分割の仕方は非常に重要である。

* 時には、常識が誤った方向に導くことがある。
* 通常、デジタル回路によって制御されるアナログ回路があった場合、2つのブロックに分けられがちである。
* 上記のように分けてしまうと、アナデジ間の制御信号の抽象度が非常に低くなるだけでなく、2つのモジュールがセットでないと、検証ができなくなる。
* モジュールを一つにして、ブロック(always?)で分割するのがよい。


Types of Modeling
====================================

* 一般的に、大規模システムの検証に用いられる抽象度のレベルとしては、下記のものがあり、用途・目的に応じて、適切な使い分けが必要。

  * Device based design(Spectre, SPICE): 回路図から生成されたネットリスト、もしくは、Pure SPICEで解釈可能なマクロモデルで記述されたネットリスト。

  * Analog modeling(Verilog-A): 電流/電圧の関係式を記述したモデル。アナログソルバ(SPICE)で解かれる。

  * Mixed-signal modeling(Verilog-AMS, VHDL-AMS): アナログ動作とデジタル動作が同時に記述可能なレベル。

  * Discrete real number modeling(Verilog-AMS, VHDL, SystemVerilog): 電気的な動作を実数の信号レベルに置き換えたモデル。インピーダンス効果(電流・電圧の関係式)は無視され、デジタルソルバで解かれる。

  * Logic modeling(Verilog, VHDL, SystemVerilog): 0,1,X,Zでモデリング。


Discrete Digital Modeling
-----------------------------------

* デジタルの入出力関係だけが記述されたモデル。デジタルソルバで解析。アナログ要素は含まない。

* Verilog, VHDL, SystemVerilogで記述が可能。

* アナログIPでもデジタルの入出力のみに着眼して、本レベルで記述されることがある。


Continuous Analog Modeling
-----------------------------------

* システムの電気的特性が記述。言語は、Verilog-A。

* 電圧/電流の関係が記述。また、積分・微分オペレータも使用可能。

* Verilog-Aモデルは、非線形常微分方程式に変換。他のSPICEコンポーネントと同様の方法でSPICEソルバにより解析。

* Trレベルと比較して、10～50倍の高速化が可能。シミュレーションのスピードアップのためには、ノード数の削減と方程式数の削減が鍵。また、弱い非線型モデルにすることで、タイムステップを伸ばすことが可能。

* デジタルの記述は全て電気的特性に変換され、SPICEソルバで実行される。そのため、論理シミュレータで解くよりも低速になる。また、IPCを用いたCo-Simで解析することも可能であるが、解析速度はアナログシミュレータのタイプステップに律速される。


Mixed-Signal Modeling
-----------------------------------

* Mixed-Signalに対応したシミュレータは、1つのカーネルで離散的なデジタル回路と連続的なアナログ回路を解くことができる。

* Verilog-AMS, VHDL-AMSが記述に用いられる。

* AMSでは、デジタルとアナログを自然にそれぞれの抽象度で記述することができる。また、データとイベントは相互に通信可能。


Real Number Modeling
-----------------------------------

* 電気的な信号を実数としてモデル化する手法。実数信号は、電圧もしくは電流のどちらかを表現するのに使用される。

* RNMは、Verilog-AMS, SystemVerilog, VHDLで使用可能。

* RNMは、デジタルソルバのみで解かれるため、SPICEと比べて1000～100万倍の高速化が可能。

* 双方向的なアナログの相関関係をモデリングすることはできない。


Combined Approaches
-----------------------------------

* 実際には、上記の抽象度のレベルを混ぜて使用されることが多い。

* 例えば、RFレシーバの場合、下記の抽象度が混在で使用される。

    * RF信号パス: RNM
    * ベースバンド, バイアス、パワー供給: Electrical
    * 制御回路: ロジック


Basic Moeling Formats
====================================

| この本の目的は、4タイプの記述方法における長所・短所に対する洞察力をつけること。
| 各記述方法における例(Programable-Gain Amplifier)を例に述べていく。


Model Operational Description
------------------------------------------------

* 差動入力、差動出力。出力には入力をゲイン倍した電圧が出力される。
* ゲインは、デジタルの3bitバス入力(GAIN[2:0])。
* 実際のPGAにあるその他のピン(電源、バイアス入力、出力のEnable信号)あり。
* 出力は、(VDD-VSS)/2を中心とする。
* 出力端子の出力抵抗はRoutとする。

 .. csv-table:: List of terminals
    :header: "pinName","expression"
    :widths: 20,70

    "INP,INM","差動入力 V(INP,INM)"
    "OUTP,OUTN","差動出力 V(OUTP,OUTN)"
    "GAIN[2:0]","ゲイン制御端子( dbmin@GAIN=000, dbmax@GAIN=111 )"
    "VDD,VSS","電源"
    "VB","バイアス入力"
    "EN","Enable信号( ハイインピーダンス@EN=0, 通常出力@EN=1 )"


AMS Programmable-Gain Amplifier Model
---------------------------------------------------

  * pga_verilogams

  .. literalinclude:: ./txt/pga_verilogams.txt
    :linenos:
    :language: verilog


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * deciplines.vamsを定義 (/common/appl/Cadence/mmsim/12.1_isr2/linux/tools.lnx86/spectre/etc/ahdl/deciplines.vams)
    * アナログ信号(入出力、電源、バイアス入力)は、electricalで定義。analogブロック内で使われI(),V()を使用して測定。アナログソルバで解かれる。
    * デジタル信号(GAIN,EN)は、logicで定義。デジタルブロック内で使われ、1,0,X,Zの値を持つ。デジタルソルバで解かれる。

パラメータ定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * 定義した数値はデフォルトで、後から変更可能。
    * Trは、スペックではない。ただし、ゲインとコンダクタを変える場合にランプ的に変更するのに使用する。設定しないと、アナログソルバでtime step errorが発生します。

内部変数定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * realとintegerは内部変数。
    * アナログブロックでもデジタルブロックでもどちらでも使用できるが、どちらか一方でしかアクセス出来ない。
    * アナログの場合はanalogブロック内でアップデートされ、デジタルの場合はinitialかalwaysブロック内でアップデートされる。

デジタルブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    1. initial文: Simulationの最初で計算される。

      * DBinc(GAINの1bit辺りのゲイン増加両)を計算。

    2. always文: Sim中繰り返し計算される。

      * GAINの各Bitをexclusive-ORする事で、入力信号にXが含まれるかを確認する。
      * GAIN[2:0]にXが含まれる場合はAdb=-40を設定、含まれない場合は、Adb= dbmin+DBinc*GAINでゲインを計算。
      * @(GAIN)が重要。これを入れることによって、always文の解析が次のGAIN信号が変化した時に評価されるようになる。これが無かったら、解析時間は0[sec]で止まってしまい永久ループとなってしまう。



アナログブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | Activeフラグは、EN信号と電源電圧、バイアス電圧で決定。
      | 電源電圧≧2.0[V]、バイアス電圧=0.7±0.05V[V]。
    * | Avは、Adb(ゲイン)をdBから比率に変更したもの。
      | Active=1の時に計算結果、Active=0の時は0.001とする。
      | Adbの急激な変化によるtime step errorを防ぐためにtransition関数で立ち上がりにTrの時間を設けている。
    * | Voctrは、コモン電圧で電源電圧の1/2。ただし、電源・バイアスを満たさない場合には供給されないため、Active信号で制御。
      | Active信号は急峻に変化するため、transition関数で立ち上がりにTrの時間を設けている。
    * | Vomaxは、出力のpeak-to-peakの最大出力のため電源電圧で定義。ただし、電源電圧が供給されていない場合には、0.001[V]とする。
    * | Vodifは、差動出力の信号成分。
      | 入力差動信号をゲイン倍したものになるが、AMPの動作電圧で飽和する。
      | min/maxで簡単に定義する事も出来るが、実回路特性に近づけるためtanh(ハイパーボリックタンジェント)関数を使用して緩やかにリミットがかかるようにした。

    .. image::  ./img/vodif.png
       :alt: Inputとoutputの関係

    * | Goutは、出力コンダクタンス。
      | EN=1の場合は1/Routだが、EN=0の場合は1/1GΩとなる。ENの2値の切換えにはtransition関数を使用する。
      | (100Ωから0.1%の変化で1MΩに到達するためEN信号による切換えは直ぐに行われる。)
    * | 出力端子の電流/電圧の関係を示す。コントリビューション文(<+)を使用する事で、分岐点における電流と電圧の関係をノード解析によって求める。
      | 出力電圧だけであれば、V(OUTP,VSS)<+Voctr+Vodif/2;で示せるが、コンダクタンスを式に加える事で電流成分も表す。


Analog PGA Model
-----------------------------------------

  * pga_veriloga

  .. literalinclude:: ./txt/pga_veriloga.txt
    :linenos:
    :language: verilog

  * アナログモデルは、デジタルソルバが無い場合、又は全PINがアナログ端子として定義されている場合に使用され、VerilogAで記述される。
  * verilogAを使用(VerilogAMSの一部)
  * verilogAMSで示したアナログブロックと同じ物を使用できる。ただし、デジタル部は存在しない。


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | 全ピンはelectrical又はその他の連続系で定義される。（熱、磁力、一方向or循環システム等）
      | ENとGAINがelectrical宣言されるのだけVerilogAMSと違い、他は同じ。

    * | 離散数(値)は時間で変化する電圧波形としてモデル化⇒シミュレーション速度が遅くなる。
      | 各デジタル信号のH→L変化にtransition波形を使用するため、多くの解析ステップが必要で通常はシミュレーションスピードが遅くなる。
      | 本モデルでは、GAINはまれにしか動かないので、スピード的には問題にならない。


内部変数定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * VerilogAMSとほぼ同じ。ただし、全てアナログブロック内で使用。
    * [追加]Gint：GAINバス入力からinteger(0～7)の値を求めるのに使用。


マクロの追加
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * デジタルノードの電圧を変換するためのマクロ(\`L())を追加
    * | アナログブロックで、1/2電源電圧をスレッショルドとしてデジタル信号を処理、
      | 条件分岐はTrueで1、falseで0を返す。

    * マクロ定義する事で、複数個所の同じ処理を簡易化（コンパイル時の影響はなし）。
    * | 例えば、EN信号のロジックレベル判定を`L(EN)と書く事で、V(EN,VSS)>V(VDD,VSS)/2の結果に置換える。
      | Activeフラグも同じ。

    * デジタルブロックで定義されていたTrue/False判定は複数個所で実行されていたためマクロ化した。


アナログブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | @(initial_step)は、アナログシミュレーションの初期ステップで評価を実施する(デジタルinitialと同じ)。
      | DBincをアナログブロック内で初期化するのに使用。
    * GAINバスは、electricalノードから`L()マクロを使ってロジックレベルを検知し、0～7のintegerを返す。
    * Adb(dbゲイン)はGintを元に計算され、Av(比率ゲイン)はAMSの場合と同じ評価式で計算される。
    * 残りのコードは、EN信号のロジックレベル判定以外はAMSと同じ。


Real PGA Model
------------------------------------------

  *  pga_wrealmodel

  .. literalinclude:: ./txt/pga_realmodel.txt
    :linenos:
    :language: verilog

  * Real numberモデルはデジタルソルバで実行される。
  * AMSモデルのデジタルブロックは再利用。アナログブロックのみ書き直しとする。

  * | アナログソルバを含まないため、負荷インピーダンスの影響はモデル化出来ない。
    | 出力は、負荷抵抗を無視した実際の電圧で定義される。

  * | wrealタイプ(VerilogAMSサポート)：
    | 64bitのreal numberとして認識し、ブロック間のデジタル値として用いられる。
    | bitやバスとは違い実数として解釈される。


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * ピンは全てwreal定義
    * 注意：wrealはdisciplineではなく、単なるシグナルタイプ。デフォルトは、logicのdiscipline。


内部変数の定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * 出力抵抗が不要になったのと、値の変化に立ち上がり時間がなくなるためRoutとTrは不要。
    * Activeはintegerとして定義する必要がなくなり、内部ピンとして定義される。


デジタルブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * verilogAMSのデジタルブロックはそのまま。
    * verilogAMSのアナログブロックをデジタル処理として置き換える。

    * | veriloaでは、ピンと変数で2つの異なるメカニズムがある。
      | 変数：real, integer又はregで宣言され、always又はinitialブロックで定義される。
      | ピン：wire(又はwreal)宣言され、wireはassign文によって制御される。

    * wire Active=...は、制御のために内部pinとして定義。式の結果が変化した時にActiveの値がアップデートされる。

    * | alwaysブロックは、コモンモードと最大振幅値計算に使用。
      | 電源又はActiveフラグの変化時に計算される。

    * | Vodiff(出力電圧差)の記述はalwaysブロックで表現。
      | ただし、この場合は@(*)をブロックに追加する事で、全変数のいずれかが変更された場合に計算されるようにしている。
      | always @(*)は、always @(Vomax, Av, INP, INN, Active)。

    * | 標準のデジタルピンは出力状態としてX(unkown)とZ(high impedance)をサポートする。
      | しかし、VerilogAMS言語の仕様はこれらの表現を含まないため、代わりに\`wrealXstate、\`wrealZstateを使用する。

    * | 出力ピン(OUTP,OUTN)はActiveとEN信号によって制御される。
      | しかし、Z状態とX状態があるため、直接wreal型のピンにドライブする事ができないのでassign文で記述する。


Digital PGA Model
------------------------------------------


  * pga_verilog

  .. literalinclude:: ./txt/pga_verilog.txt
    :linenos:
    :language: verilog

  * | 純粋なデジタルSimが要求される時や、
    | アナデジ間のインターフェースをチェックする目的でのみMixed=Signalブロックが含まれる場合に使われる。

  * Simにおけるアナログのオペレーションはブラックボックス扱い。
  * アナログ信号は、H/L信号で表現される。また、受け付けない場合はX、オフした時はZに遷移する。
  * ブロックの制御特性は内部で計算されるが、それらの値はテストベンチからのダイレクトアクセスか、プロットによる保存によってのみ測定可能。

  * | デジタルのPGAに対する典型的なアプローチは、
    | H入力をポジティブ電源(VDD=1)に、L入力をネガティブ電源(VSS=0)にする。
    | バイアスインプット可能をVB=1とする。

  * | 変換特性は、入力信号を出力信号にそのまま通す。
    | 適切にバイアスされている場合、OUTP=INP, OUTN=INN。
    | バイアスされていない場合、出力端子はHighインピーダンス(1'bz)になる。
    | 供給電源が来ていない場合は、unkown状態(1'bx)となる。

  * | ゲインはデジタルセグメントとして計算される。
    | ただし、単なる内部のreal変数であり、変換特性には影響しない。


Additional Model Coding Examples
====================================

| このセクションでは以下の四つのモデリングアプローチそれぞれを用いて、Verilog-AMSの代表的なモデルを示す。

  * Dフリップフロップのデジタルモデル
  * オペアンプのアナログモデル
  * ADコンバータのAMSモデル
  * 離散時間ローパスフィルタのRNモデル


Digital: Verilog D-type Flip Flop
------------------------------------------------

  *   Verilog言語は論理的関係性を定義
  *   ここでは標準Verilogフォーマットによって書かれたD-FFモデルを例に述べる
  * | この例では入力Clockのエッジを読み込み、出力Qにはデータ入力が読み込まれ通される
    | 出力Qbは常に出力Qの補出力である
  * | モデルは非同期リセット式
    | ResetがhighのときはいつでもQは0になる
  *   以下にD-FFの簡単な記述を示す

  .. literalinclude :: ./txt/d_ff.v
    :linenos:
    :language: verilog
    :lines: 1-9

  *   Q出力はClockかResetの立上りエッジで更新される
  * | Qbノードの更新はQ信号の反転と同等の値が連続的に保たたれるように代入文を使用される
    | 動作コードによって駆動していないため、Qbはreg宣言されない
  *   以下にD-FFの動作をチェックする簡単なテストベンチを示す

  .. literalinclude :: ./txt/DFF_TB.v
    :linenos:
    :language: verilog
    :lines: 1-13

  *   DFF_TBは外部ピンが必要とされないシミュレーションのトップレベルのテストベンチモジュール
  *   DFF1モジュールはインスタンスDUTとしてインスタンス化され、Clockへ100MHzのパルス波を打ち込み、そしてDataとResetを数度変化させることで期待通りにブロックが動作するかの検証を行い、モジュールではこれらで駆動する信号とレジスタを定義する

  *   留意すべきは、離散timescaleはこのテストベンチモジュールのために規定されているということである
  * | すべての離散およびミックスドシグナルのVerilogブロックは、離散時間のためのresolutionとtime unitを定義するために複数のtimescaleを利用する
    | ここで示したようにモジュールに、標準includeファイル内で、コンパイラオプションで、など定義場所問わない
  * | システム内で遅延定義のために#演算子を用いている
    | モジュール固有の演算子(この場合は#)はここで定義するためにtime unitを必要とする
    | このケースではtime unitはnsで定義され、#5は5nsを示す
  *   モジュールがあらゆるところで一貫して定義されるように、プロジェクトのtimescaleとresolutionを定めなければならないことに注意
  *   一般的に、(もっとも一般的に1nsか1psの時間単位)デジタルモデルの標準的な実行と、(システム速度に応じて1nsから1asにわたる)プロジェクト条件に基づいてきまるresolutionによって選ばれる。

  *   DFF1_TBモジュールのシミュレーション波形結果を以下に示す

  .. figure:: ./img/fig4.png
    :scale: 75%

  *   Qは初期値を設定していないため、Data入力がassignされるClockの最初の立上りエッジまでは不定値(X)であることに注意
  *   DataがHigh/Lowに変化すると、次のClockの立上りエッジでQの値が変化する
  *   ResetがHighになるとすぐにQはLowになり、ResetがHighの間はClockが叩かれてDataの値が変化してもQには影響しない
  *   Resetが解放されると、次のClockの立上りエッジで再びDataの値をQへと伝搬させる
  *   Qbは常にQの反転である


Analog: Verlog-A Operational Amplifier
------------------------------------------------

このセクションでは、Verilog-Aの例として、OpAmpを解説。

  * アナログビヘイビアモデルの設計は、ピンの入力と出力の電圧・電流の関係(線形性、非線形性、積分関係、微分関係)に着目して、モデリングを行う。

  * また、入出力のピンだけでなく、内部変数を用いて、時間依存の関係は、離散的なイベントの処理を行い、出力信号は、入力信号値や内部変数値の関係で記述される。


  * 単一の特性だけでなく、一つのモデルで複数の特性を表現することがある。

  * ここでは、以下の特性を持ったアンプのモデルを例として説明する。

    * DCゲイン
    * オフセット
    * クリッピング
    * 出力インピーダンス
    * ポールの周波数特性


  * このようなモデルを開発する際には、先に等価回路を導く必要がある。その後、そのトポロジをモデルに書き下す。

  * オペアンプの等価回路を下記図に示す。

    .. figure:: ./img/opamp_circuit.png
      :scale: 75%

    * Icur: 入力差(inp, inm)に応じて、電流値を出力する電圧制御電流源(VCCS)。出力段をドライブする。Icurは、Rresに流れ、DCゲインを生成する。
    * Vctr: 入力差が0の場合、電圧源Vctrが、DC出力電圧を電源電圧の中間値になるように調整する。
    * Ccap: ポール位置の調整をするための容量。
    * Ilim: 非線形電流源。内部ノードNが供給電源以上にならないように、電流をシャントする。ダイオードによるリミッタの働き。
    * Rout: 付加的な出力抵抗。DC的には、出力抵抗は、RoutとRresの合成抵抗となるが、AC的には、容量CcapとIlimによる低インピーダンスの経路の存在により、ノードNがほぼグラウンドにショートされる。そのため、出力抵抗は、Routとなる。

  .. literalinclude:: ./txt/Amp1.va
    :linenos:
    :language: verilog


  * モデルの正しさを検証するために、テストベンチを作成する。

  * Verilog-Aモデルの場合、回路図作成環境でテストベンチを作成し、様々な条件下でいくつかのシミュレーションを実行する。

  * アンプの場合、閉ループ特性、開ループ特性、線形動作領域、飽和動作領域の検証をDC/AC/Tran解析を用いて行う。

  * 下図にテストベンチを示す。このテストベンチでは、フィードバック抵抗をR1, RFでパラメータ化しており、このパラメータ値を調整することで、開ループ/閉ループを切り替える。

    .. figure:: ./img/opamp_testbench.png
      :scale: 75%


  * DCスイープシミュレーションの結果を下図に示す。この解析では、特に、線形領域と飽和領域の連続性を検証することができる。また、閉ループ特性を検証することで、フィードバックループが存在している場合のモデルの収束性を検証することもできる。

    .. figure:: ./img/opamp_dc.png
      :scale: 75%


  * AC解析は、周波数応答を検証するために使用される。

  * 開ループ特性では、小信号ゲイン、コーナー周波数、位相の関係を検証することができる。

  * 閉ループ特性では、フィードバックループに依り、ゲイン特性と位相特性が望ましい値になっているかを検証できる。

    .. figure:: ./img/opamp_ac.png
      :scale: 75%

    * テキスト通りの開ループ特性を得るためには、リミッタ電流源を無効にしなければいけなかった。


  * Tran解析では、ステップ入力をアンプに加えることで、線形性と非線形性の直接の関係を見ることができる。

    .. figure:: ./img/opamp_tran.png
      :scale: 75%

  * 上記の例では、±100mVをゲイン1の設定に対して、加えた場合、出力は完全に入力に追随している。

  * ゲインを10に設定した場合、出力は10倍になるが、応答はそれほど速くはならない。また、開ループの応答は、決まったスリューレートに制約されているが、電源電圧付近に達すると飽和してしまう。


  * テストベンチを回路図で書くことが、ベストか?

  * Verilog-A/Verilog-AMSのネットを使用して、テストシーケンスをファイルに書き、また、特性の測定も記述することができる。

  * AC解析と同じ結果を見るためには、回路をsin波でドライブし、出力の振幅と波形のズレを観測すればよい。この方法により、シミュレーション時間は増大するが、再利用性が高まる。

  * テストベンチをテキストで書くことで、多数の条件を一度のシミュレーションで実行し、かつ、結果のインスペクションが可能となる。



Mixed-signal: Verilog-AMS Digital to Analog Converter
--------------------------------------------------------

* A digital to analog converter(DAC)の記述

* 本モデルの第一の入力はデジタルのバス入力である

* 入力が変化すると、出力電圧は参照電圧の比率として計算された電圧となる

* 離散信号によって制御されたアナログ出力を定義するときは注意が必要

* アナログ出力がある値から別の値へ離散的な変化をするならば、重大な数の問題が起き、シミュレーションがスローダウンするか、収束エラーが起きる

* 離散的に変化する量は、階段変化をランプ波形等の連続波形に変換しなければならない。

* 本モデルでは離散的な変化に対しtransition filterを適用する

* デジタル入力の有効性(不定値)がチェックされなければならない。

* 本モデルではイリーガルなバス値のときに出力電圧を0としている

  .. literalinclude:: ./txt/dac.vams
    :linenos:
    :language: verilog

* DACテストのテストベンチはVerilog-AMSでシンプルに記述される

* ひとつのinitialブロック内に離散値とアナログのスティミュラスを記述し、
  シーケンシャルな変数リストと、次の値へ変化するまでの時間とで構成される

* 最後の数行に、入力が無効になったときと供給電圧値が変化したときの出力テストがある

* これはブロックレベルでのビヘイビアモデル検証で含むべき標準的なチェックである

* 典型的な入力だけでなく、期待されない入力時のモデルのファンクションを適切にチェックできる


  .. literalinclude:: ./txt/dac_tb.vams
    :linenos:
    :language: verilog


  .. figure:: ./img/DAC6_TB.png
    :scale: 50%


* より洗練されたモデルにおいては、バイアス入力の要求仕様、非線形性 and/or デジアナ変換時のランダムオフセット等の特性も含めるべきである。

* これにはより包括的なテストベンチが必要で、特定の入力信号を生成、出力波形を取得、要求された特性の計算を行うテストベンチが必要である

* Verilog-AMSは、これらを自然に記述することができる

* 推奨される方法は、特定のテストと出力がスペックを満足しているかのレポートを、taskで定義することである

* 例えば、デジタル入力に特定の値を入れ、出力値が正しいかどうかをチェックようにtaskを定義する

* taskの動作

  1. Dinに特定の値を入れる。
  2. 出力が反応するまでの特定時間待つ。
  3. 出力期待値を計算する。
  4. 実際の出力と期待される出力を比較し、スペック外であればメッセージを出力する。
  5. テストのpassとfailの数をカウントする。

* 以下、上記動作の記述を示す。各入力値において出力が期待値の1%以内かをチェックする。


  .. literalinclude:: ./txt/d2acheck.v
    :linenos:
    :language: verilog


* taskを利用して、特定コードのチェック、適切な動作検証のためのテスト手順を記述することができる。


  .. literalinclude:: ./txt/dac_tb2.vams
    :linenos:
    :language: verilog


  .. figure:: ./img/DAC6_TB2.png
    :scale: 50%


* このようなテストは仕様変更による繰り返しテストを行うときに特に役立つ

* テストベンチはモデルが定義された仕様を満足するかテストされているかどうかをレポートする。

* 同じテストベンチをトランジスタレベルのテストでも使用でき、各viewが定義された精度内で仕様にマッチするか検証できる。

* 検証手順のコード開発に多くの時間がかかるとしても、このアプローチは検証プロセスの自動化にを助けることができる。

* アナログとMixed-Signalの検証プロセスにおいて、一度このような手順を標準的に実行すれば、すぐにシステムレベル検証手順の用途に適用することができる。


Real Number Modeling
--------------------------------------------------------

  * RNMでは、アナログの電圧値は、時間変動の実数シーケンスとして表現される。実際には、これはアナログシミュレータが行っていることと同じである。アナログシミュレータとの違いは、モデルが方程式として定義されているかどうか、という点である。回路シミュレータは、回路トポロジからキルヒホッフの法則に基づき、方程式を作り、その方程式を各タイムステップで全体を満たすように解き、電圧・電流を求める。それに対して、離散システムでは、電圧対電流の関係式はなく、また、キルヒホッフの法則も、方程式を同時に解かないといけない、という制約もない。電流の効果やフィードバック機構の影響を無視(これにより、ドライバと負荷の間の相互関係はなくなる)した入力から、出力を直接計算するだけである。

  * これは、抽象的すぎる計算モデルであり、トランジスタレベルのシミュレーションとはかけ離れたものである。しかしながら、トランジスタレベルよりも遥かに高い抽象度でシステムを記述することで、システム全体の関係を記述することができる。入力が変動した場合、信号は回路ブロック(例えば、比較回路、スケール回路、変換回路、フィルタ、遅延回路、スリュー回路など)により処理され、出力信号が生成される。このようなRNMのコンセプトは、システムの検証だけではなく、探索にも使用できる。トランジスタレベルでサブシステムを検証し、その後、そのブロックのビヘイビアモデルを使用して、システムを高抽象度で検証するのは、もはや常識である。また、AMSモデリング技術ではなく、実数技術を用いて、ビヘイビアモデルを作成することは、前述の自然な拡張であり、システムレベルの検証において、スループットを高めることができる。

  * 実数モデルのコンセプトは、簡単なものである。もし、入力/出力の関係が伝達関係にあるならば、入力が変化した時に、出力が更新されるという関係を数式で記述すればよい。固定電圧(バイアス、電源など)の場合も単純である。電源電圧や、バイアス電流、電圧入力は、実数値としてモデル化される。シミュレータは、それらが適切な許容範囲であるか、出力が適切なバイアスで制御されているかどうかチェックする。これらの動作は、PGAの例で既に記述したとおりである。

  * 実数モデルで、時間変動の波形を表現するためには、もう少しやるべきことがある。アナログ記述言語では、立ち上がり時間を指定したり、スリュー、積分、微分などのアナログフィルタはビルトインとして用意されているのに対して、実数モデリングでは、このような関数は自動的に使用することができない。代わりに、離散システムでシステムを記述する必要がある。大抵の効果は数行で書くことができるが、いささか経験が必要となる。もし、実数モデルを始めるならば、最初にこのような関数をライブラリ化しておくことをお勧めする。これによって、経験の無さを補うことができるだけでなく、効果的に利用することができる。一度このような伝達関数の変換を経験すると、今後、アナログ特性を離散モデルに変換するのに役に立つであろう。

  * アナログシステムでは、積分動作はよく使用される。離散システムでは、入力は時系列のデータとして与えられ、出力は入力の過去の値と現在の値から、台形積分法を用いて計算される。

      OUT_new = OUT_old + (T_new - T_old)*(IN_new + IN_old)/2

    つまり、入力が変化した場合、新しい出力(OUT_new)は、T_new, IN_newから求めることができる。


Verilog-AMS/wreal Low-pass Filter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  * ローパスフィルタは、離散システムの時間応答の定式化に非常に役に立つ例である。アナログドメインでは、フィルタ特性は、ポールとゼロ点を持つ多項式として記述される(H(s)=N(s)/D(s))。このラプラス形式の表現は、周波数領域ではよく機能し、また、RLC回路に簡単にマッピングできる。しかし、イベントドリブンな離散システムでは、この形式は抽象的過ぎる。離散システムでは、フィルタ特性はZ領域で記述される。Z領域では、出力は、入力の項と、遅延された入力の項で表現される。

  * H(s)からH(z)に変換する方法には、標準的なものがある。

  * 例として、1次のローパスフィルタを考える。周波数領域では、以下の伝達関数で与えられる。

      H(s) = OUT / IN = 1 / (1 + s/Wp)
        Wp: コーナー周波数[rad/sec]

    H(s)からH(z)の変換には、以下の双一次変換(Bilinear Transform)を用いて、変換することができる。

      s = (2/Ts) * (1-z^(-1)) / (1+z^(-1))
        Ts: サンプリングレート, z^(-1): 単に遅延素子

    これをs領域の伝達関数に適用すると、

      H(z) = 1 / (a + (2/WpTs)(1-z^(-1))/(1+z^(-1)))

    (1+z^(-1))を分母・分子にかけると

      H(z) = (1 + z^(-1)) / (1 + 2/WpTs + (1 - 2/WpTs)z^(-1)) = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))

    ここで、

      n0 = 1, n1 = 1, d0 = 1 + 2/WpTs, d1 = 1 - 2WpTs

    である。次に、結果の差分式を計算する式をコードに落とし込む。

      H(z) = OUT / IN = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))

    INとOUTの関係を導くために、式を変形する。

      OUT * (d0 + d1*z^(-1)) = IN * (n0 + n1*z^(-1))

    OUTについて解く(z^(-1)は、遅延単位素子であることを思い出す)。

      OUT = (n0*IN + n1*z^(-1)*IN - d1*z^(-1)*OUT) / d0

    最後に、z^(-1)を過去の値に置き換えることで、望ましい式を得ることができる。

      OUT_new = (IN_new * n0 + IN_old * n1 - OUT_old * d1) / d0

    ローパスフィルタのVerilog-AMS/wrealのコードを以下に示す。

      .. literalinclude:: ./txt/lpf1s.v
        :linenos:
        :language: verilog

  * 上記のモデルが正しく動いているかは、ステップ入力を与えた時に出力が適切な時定数で動いているかどうかで検証することができる。3つのローパスフィルタ(それぞれ、異なるコーナー周波数を設定)を配置し、ステップ入力を与えるテストベンチと波形を以下に示す。

      .. literalinclude:: ./txt/lpf1s_tb.v
        :linenos:
        :language: verilog


      .. figure:: ./img/LPF_WREAL.png
        :scale: 75%



Modeling Best Practices Considerations
===========================================

| 特性を上手く定義してコーディングしたモデルは、リーズナブルに保証する事が出来る。
| ただし、そのようにモデリングするには、以下の３つを実施する必要がある。


1. | モデルに何を表現させるか決定する。
   | 通常、モデルを作成する時間よりも、ブロックのモデルとして何を書くべきかを明らかに定義する時間を長く取る。


2. | 必要なオペレーションが行われるために正しくコードを記載する。
   | さまざまなモデル作成方法を検討し、モデルに何を描く事が出来るのかを余裕を持って考慮しなければならない。
   | モデル作成者のコード生成に影響し、そしてシミュレーションの効果にも影響する。


3. | モデルが正しく動く事を証明する。
   | すべてのテストケースを試験する事が出来るテストベンチを書く事は、モデル開発とは別です。
   | それを作成するためには非常に長い時間がかかる。テストは文字通り、モデル開発の後ろ半分になります。
　

| モデル開発でほとんどの時間として取られているのは、コーディングではないと認識しなければならない。
| しかし、良いコーディングの練習は、モデルの効果的な使用方法に重要です。
| 各種のモデリング記述はモデル開発のプロセスにおいて助けとなるでしょう。


Analog Best Practices
------------------------------------------------

* | SPICEのようなアナログシミュレータは、全(非線形)システムの全ての方程式を解くためにNewton-Raphson[1]型の反復技術を使います。
  | ビヘイビアモデル、トランジスタモデル、接点からなるキルヒホッフの法則から、各タイムポイントにおけるネットワークを解きます。
  | ビヘイビアモデルは他のシステム内臓モデルに拡張される。
  | 良い結果を提供するシミュレーターの能力に影響を与え、解の収束性を上げるのは、モデルの品質です。


* | 良いモデルを開発するための鍵は、シミュレーターがそのモデルをどのように扱うのかを理解する事です。
  | ほとんどのアナログシステムは、その回路にフィードバックを持っています。
  | アンプは、その特性を制御するためにクローズループを使っています。
  | トランジスタレベルのデザインでは、時々、正しい動作を作るトランジスタの間の複雑なフィードバック関係が使われています。
  | そして、単純な抵抗ドライバーもフィードバックシステムであり、電流-電圧方程式を入力信号と出力電圧を比較して解かなければならない。


* | A direct solution method[2]は、もしリニアシステムだけが定義されている場合に、直接、同じポイントの電圧と電流をイタレーションなしに計算する方法です。
  | しかし、実際のシステムでは完璧なリニア特性はありません。
  | 全てのものには、オペレーションに境界があり、しばしば電源リミット、又はトランジスタによって発生するパフォーマンスリミットによって引き起こされます。
  | システム内で、本質的に非線形トポロジーの変化をON/OFFする事が一般的です。


* | 一般的なアナログシミュレーションは、各小ステップで線形性を超えると、十分に短いタイムステップに時間軸をします。
  | これは小さなタイムステップを超えて起こるべき現象を説明する連立方程式の解を計算可能にします。
  | シミュレーターが各ステップでどの程度の誤差になるかによって、かなりの量の推測[1]が入ります。
  | 問題なく解を得られるタイムステップの大きさを、そして新しいタイムポイントでキルヒホッフの電圧-電流法則を解くために十分な解が得られるイタレーション回数と収束を決定します。


* | 非線形システムの場合、このイタレーション行程は保証されない。各イタレーションは非線形の関係を再評価するたために要求される新しい解を推測します。
  | もし、解が確かなイタレーション回数の内に十分な精度の値に収束しなかったら、シミュレーターは非線型のためにはステップサイズが大きすぎると想定し、そのポイントの計算をあきらめます。
  | そして、それは、前のタイムポイントよりも小さなタイムステップで再計算します。


Cause of Transient Solution Problems
-----------------------------------------------

ここに、収束性の問題が発生する原因となる事をリストアップした。


* | 解をもたない方程式のシステムを立てられる事
  | - 方程式を解くために虚数値が要求されるフィードバック
  | - 回路のオープンノードに理想電流が流れ込むトポロジー
  | これらのシチュエーションは、現実には起こりえない。しかし、ビヘイビアコードでは完全に理想的なデバイス又は方程式を記述する事によって簡単に定義する事が出来る。


* | 有効な解の範囲を持つ方程式のシステムを立てられる事
  | - 変換特性に"デッドゾーン"があるフィードバック
  | - どこからも接続されていないノードを定義したスイッチング
  | ビヘイビアを定義するための方程式が存在しないこれらのシチュエーションの結果は、幾つかの値は正しいだろう。この問題は、システムが有効範囲のいかなる値も想定出来ないという事である。
  | 全体のシステムの方程式を解くための連立方程式において不適切な方程式がノードにあった場合、解くことが出来ない不良条件マトリックス[3]と数学上呼ばれる結果になる。


* | ビヘイビアモデルにおいて、コントロールの変化が発生した際に（if/else関係に基づき、又は離散値に基づき）一つの値から別の値へ不連続に変化するアナログの出力特性を定義するのは簡単である。
  | この手のアナログドライバーの問題は、システムが記述された値変化に正確に対応しなければならない事です。
  | もし、シミュレータが、このような離散値変化が発生した時の解にイタレーションに問題があった場合、そのオプションはとても限定的です。
  | より短いタイムステップで試そうとし、しかし離散的な変化を作れなかったならば、シミュレーションは収束に失敗するか、精度を無視してより短いタイムステップでの計算を続けます。どちらにせよ解決法は無い。


* | スレッショルドを超えた時に入力依存のあるゼロから、入力依存のある有効値まで変化するモデル（一般的には、部分的に線形なタイプの変換特性が定義されたモデル）は問題がある。
  | もしそれらの関係が、フィードバックの変化に寄らずに入出力変換特性が使われていたなら、正しくシミュレーションできるだろう。
  | しかし、もしこのタイプの依存にフィードバックが使われていたならば、ファンクションへの入力値は、ファンクションの出力に依存して定義される。
  | イタレーションの問題は、シミュレータが変換関係において横切った時に起こるだろう。
  | ３つの現象が、問題の原因である。


  * | もし、入出力依存のスロープが１セグメント内でゼロの場合、Newton-Raphson法アルゴリズムのイタレーションは、正しい解より近い入力を得るための変化を決定するために、そのセグメント内で利用できる情報を持ちません。
    | そのため、解が無いと、ソルバ－に返します。


  * | Newton-Raphsonイタレーションアルゴリズムは、入出力変換特性のスロープに基づく方程式のセットを解くための探索を試みます。
    | 図12は、通常のイタレーションにおけるF(x)=0の式を解くための行程を示します。
    | x=P0点で始まり、f(P0)値とその点において方程式の解で推測された線形を仮定した場合のスロープを使う。
    | 全連続の変換特性のため、この手順が実際の解に高速に収束させるゼロクロスポイント周辺の値の幅となる。
    | しかし、部分線形フォーマットで定義されたファンクションの場合、収束は単に適切なセグメント内に予測したポイントがあるかを観察するのみ。
    | この場合、一般的なNewton-Raphsonイタレーションは解を生成しない。そして、幾つかの他のアプローチによって解を見つけなければならない。
    | この問題が、数千の方程式を持つ中規模のシステムで発生した時、解法につまづきFailします。


  * | もし、シミュレータがスロープのステップ変化を変更したなら、非線形性の高いシステムの兆候として急激な変化を解釈、そして小さなタイムステップに力を入れるだろう。
    | 期待よりもより多くの計算点がシミュレーションに必要となる。


Propoer Analog Expression Development
-----------------------------------------------

* | アナログシミュレーターのイタレーション問題を避けるための一つの方法は、ビヘイビアモデルの信号タイプを把握しておく事である。
  | アナログreal変数、又は値は、機能のタイプとして以下の３つの内の１つのタイプを持つを持つ。


  1. | Continuous
     | 値にステップ的な変化が無い。
     | 電圧や電流が自動的になるタイプで、時間変数$abstimeと$realtimeそして、このタイプの式の計算の組み合わせが可能。
     | 連続信号は、アナログ電圧又は、電流を制御に使う事が出来る。

  2. | Discrete
     | 値は、ほとんどの時間一定である。しかし、特別なタイムポイントにおいて、新しい値に変化する事が出来る。
     | これらの定義は、値を選択するためにif又はcase文を使用して作る事が出来る。
     | 又はイベントドリブン構文@(cross())又は@(timer)を通して、integer変数に依存、又はAMSシステムの分散的な変数に依存して作られる。
     | discrete信号は、アナログ回路の制御に使用する場合には、transitionフィルターを通すべきである。
     | これは、分散値の変化が発生する時にゼロではない立ち上がり時間を挿入し、連続したフォーマットに変換する。

  3. | Mixed
     | 電圧又は電流のどちらかで連続的に変化する値、又は新しい値に分散的に飛ぶ。
     | これらの信号は、アナログ設計における問題の共通の源である。
     | それらはきれいに連続値に変換する事が出来ない。
     | 連続的な結果が欲しい場合、連続的に組んでいるブロックの再構築をする必要がある。
     | これをするためには、それらの分散成分は分離され、連続系にはtransition filterによって変換して渡されるべきである。
     | そして他の連続変数と再結合する。

* | 莫大なアナログモデルの問題は、上記の推奨がなされていない事が原因で起こる。
  | 問題は、discrete signal(2又は3)が電圧又は電流、連続的な入力信号が想定される演算で使われている事による。
  | 同様に、discrete signalが予想される演算でcontinuous signals(1又は3)が使われる時も。


* この問題を悪化させる１つの一般的な問題は、簡単なテストベンチでアナログ信号にdiscrete制御を含むモデルのシミュレーションが通る事にある。

* | これらの疑わしいテクニックが問題なく使える事で判断をなまらせ、結果としてプアなモデリングで良いと信じてしまう。
  | システムが大きくなるにつれ、指数的に問題の発生する確率が増加する。
  | 単純なテストベンチで証明されているモデルで、結果として大きなテストベンチでシミュレータは突如として動かなくなる。

* | **アナログピンを制御する信号の定義は、連続値のみで構築されなければならない。**
  | **全てのdiscrete信号は、連続系で使用する前に必ずtransitionフィルターによる変換を通さなければならない。**



Example of Modeling with Proper Continuity
-----------------------------------------------

* | モデリングに注意が必要な簡単な例はアナログのマルチプレクサです。
  | デジタル入力SELを持ち、IN0かIN1を出力に接続するAMSモデルを考える場合、一般的なアプローチでは選択された入力で出力を制御するためif/else分を使用します。
  | このモデルは、SELが変化しない状態が長く続き、SELが変化した時に出力が異なる出力値に急に変化する。
  | このような、アナログ出力を制御するSELにおける離散変化がある場合、後の方で問題となる。


      .. literalinclude:: ./txt/mux0_1.vams
        :linenos:
        :language: verilog


* | これを修正するためには、SELの離散変化をランプ的な変化に変換しなければならない。
  | １つのアプローチは、transition関数を使用してSELを0から1までのランプ変化の信号に変換し、ランプ値によって出力を定義する方法である。
  | これは、出力電圧が２つの値の間でランプ的になっているため、前のものより良いモデルとなっている。
  | しかし、これは出力に対する理想的な電圧制御であり、理想的なMUXである。


      .. literalinclude:: ./txt/mux0_2.vams
        :linenos:
        :language: verilog


* | MUXのより一般的なモデルは、スイッチ部分をモデル化したものである。
  | 電流が入力から出力へ流れ、出力は入力＋スイッチの"ON"抵抗のインピーダンスが見える。
  | より現実的なモデルは、入力から出力へのコンダクタンスをモデル化、２つのスイッチの関係を使用して２つの枝(IN0からOUT、IN1からOUT)を定義する。
  | これは、その状態が切替わる時にアナログの連続した応答を十分にモデル化したものになる。
  | SELが0から1に変化した時、IN0とOUTを接続するコンダクタンスは下方向にランプ化され、同時にIN1とOUTを接続するコンダクタンスは上方向にランプ化される。


      .. literalinclude:: ./txt/mux0_3.vams
        :linenos:
        :language: verilog


* このモデルには、さらに以下の２つの効果が追加されている。

  * | SEL値は'=='ではなく'==='を使用してチェックされる。
    | 4-stateのロジック信号は、0,1,X,Zの値を取る。
    | 標準的な等価演算子('==')を使用する場合、入力として'=='を使用してチェックできない値の場合、等号式の結果はunknownになる。
    | 4-stateロジック用の符合・同一演算子('===')を使う事によって、等しい場合にはTrueを返し、そうでない場合は全てFalseを返す。
    | そのため、入力がX又はXの場合、このモデルはどちらの入力とも接続されない事になる。


  * | モデルに"off"の出力抵抗(Roff)を定義している。
    | もし、"off"条件でコンダクタンスを0と定義した場合、出力にアナログ負荷が接続されずフローティングになる。
    | 電圧方程式の欠如によりシミュレーションがfailする。


* | この変換の１つの興味深い結果は、理想的なMUXの抽象的なモデルは、実際のMUXの電気構造を模倣したモデルになるという事である。
  | 実際のデバイスは限定された時間でスイッチがオンし、限定されたon/off抵抗を有する。
  | 一般的動作の自然なモデリングは、スイッチのON/OFFをモデル化するのに最も効果的な方法で、理想的なモデルは結局のところ問題を作り込むに過ぎない。


      .. figure:: ./img/sim_mux0_tr.png
        :scale: 100%

Modeling Systems with Direct Feedback
------------------------------------------------

* | 出力から入力の一つのノードに直接フィードバックされているようなシステムを定義した時、ノード電圧の値を求める為に各時間でシミュレーションは繰り返し計算を行う。
  | 例えば、クローズループのAMPモデルを含むシステム等。


* | もし変換特性のスロープが分散的に変化する（変換特性が部分的に線形な）場合、スロープが変化するステップをまたぐところで
  | 重大なイタレーション問題が発生する。
  | これは推定を変換特性のスロープをもとにした値にアップデートする非線形解法手順の内部動作によって引き起こされる。
  | フィードバックに含まれる変換特性のスロープ（つまり、一次微分係数）を変化するステップは、値を変化するステップ（不連続値）で
  | 通常起こるのと同様の問題を引き起こす。
  | このような不連続な変換特性は、解なし又は複数解があるという結果をシステムに返す。つまり、アルゴリズムがより近い値を推測できずに結果的にシミュレータの未収束が発生する。


* | 効率的なシミュレーションのためには、フィードバック内の飽和限界とすべての非線形インピーダンスタイプをダイレクトフィードバックで制御する事が
  | 出来るように、値とスロープが連続の変換関係で定義するべきである。そして（変換特性にゼロの傾斜を持たない）単調である事が望ましい。
  | このようなケースの単純な非線形は、部分的に線形な変換特性よりも、hyperbolic tangentや、指数関数、二乗関数など入力の連続関数でモデル化される。


Digital Best Practices
-----------------------------------------------

* | Verilogにおけるデジタルのモデリングについては多くの本や、Web[5]に記述があるが、これらは合成するためのコードを開発するためのもので
  | ミックスドシグナルのビヘイビアモデルを作成する目的のものではない。


* | AMSの章において、descreteのプログラムのゴールは機能を記述する事、そして妥当性の範囲を定義する事です。
  | 多くのケースで、デジタルモデルはアナログ動作を設定するための制御(discrete real)として、又はアナログ比較の状況をレポートするために定義されます。


* | 技術者がいくつかのdescrete動作を作るために必要なアナログモデリングを知っていると、幾つかの誤解が問題の原因になるだろう。
  | アナログモデリングにおいて、すべてのタイムポイントですべての計算が行われる。
  | もしこの考えがデジタルモデリングに引き継がれた場合、モジュールは、いかなる変化にも対応するように1つの大きなalways文で書かれるだろう。
  | これはdescreteコードとしては効果的なアプローチではなく、実際の要求よりも多くの計算を必要とするコードになってしまう。
  | descrete処理を定義する時、全信号のアップデートはごく稀な処理のため、変換特性を分解する事によって、モデルはコードの小さなセグメントだけを評価するようになり、モデルのより効果的な実行が期待できる。


* | もう一つの一般的な間違いは、連続に起こる依存の処理です。
  | 単純に入力が変化した時にいつでも出力がアップデートされる（always @(vars)又は、assign文で)か、
  | 又は入力がサンプリングイベントが発生した時(always @(<event>)文)にアップデートされるか、
  | 又は入力が一定時間で応答を変化させるように特定のタイムステップサイズで再計算させる(always #(td)文)かを決めなければならない。

* | 例外処理は非常に重要です。
  | ブロック記述では、目的の入力が提供された場合にそのブロックが何をするかを記述するが、すべての入力が検討されなければならない。
  | 入力がXやYの場合や、妥当でない選択をした場合、電源電圧やバイアス値が範囲外にある場合にどういった動きをするかを決める必要がある。

* | 無効状態からどのようにモジュールが回復するかを定義するのも重要である。
  | 例えば、組み合わせ論理で、入力が無効値から有効な値に変化した場合、入力が有効になる又はリセット信号がかかるまでunkown出力が続く。
  | そのようなイベントが発生したら、出力値をunkownにする、そしてシミュレーションの残りをその状態を保つモデルを作るのは簡単である。
  | 入力として無効な信号が入力された時に、アサーション（第4章参照）を挿入する、又はWarningメッセージを出力するのに良いやり方である。
  | 回復できないような壊滅的な制御コンディションがあった場合、エラーメッセージが出力されるか、assertionで何が起こっているかの詳細が示され、シミュレーションが終了するべきである。


 

Mixed-signal Best Practices
-----------------------------------------------

 * 最高のモデルを作成するためにシステムの離散時間/連続時間間の相互通信は解釈される必要がある。
 * full iterationのアナログソルバと、時間通りに前進していくだけのデジタルソルバのバックステップ機能にマージされる。

 【DC operation】
   * DC動作点解析は、システムのアナログ部分の静止点の計算はもちろん、デジタル部分に必須のすべての初期化とゼロ時間演算を行う。
   * | まずデジタルの初期化を行ってからアナログ動作点解析を行うのは標準的技法である。
     | これは、アナログ動作点解析でデジタル値を利用している場合に、動作点を探すのが難しく、より多くの時間がかかるためである。
   * 以下にMixed-signalシミュレータのアナログ-デジタル間DC動作点解析の一部の典型的な例を示す。
 　
     1. すべての個別の初期化が実行される
     2. すべての個別のinitialブロックが時刻0で実行される
     3. すべての個別のalwaysブロックが時刻0で実行される
     4. アナログシステムはすべての電圧/電流の解に適応される
   
   * もしシステムの一部にVHDL-AMSが用いられていたら、よく似てはいるが言語仕様が異なるため若干の異なる初期化プロセスが要求される。

 【Transient operation】
   * DC動作点をひとたび計算すると、過渡解析手順はその点から始まり、以降の計算が繰り返される：
   
     1. | アナログソルバは、timestepサイズを線形成と正確な制約に基づいて選び、どのtimestepも制限制御される。
        | T1における新たな解が実際のT0からT1=T0+ΔTのtimestepに繰り返し適応される。
        | もし解に収束しないと、アナログソルバは現在よりも小さなtimestepを選ぶ。
        | この過程は収束するか、timestepサイズが最小値になる(収束失敗する)まで繰り返される。
     2. デジタルソルバはT0+からT1までのすべての離散stepで連続して実行される。
    
   * 離散イベントが発生しないもしくはこのtimestep内でアナログ解に影響を与えるようなデータが変更されたら、次のtimestepまで繰り返される。
   * デジタル回路の活動水準やデジタル解、アナログtimestepサイズ次第でアナログtimestepに含まれるデジタルイベントがいくらでもある。


   * シミュレーション環境ではアナログの結果は、最初に評価されるデジタル部分の間連続的に手に入れられ、離散コード(initial/alwaysブロック)で測定するアナログは効率的に動作する。


   * | もしアナログシミュレータが離散データやtimetep中にいくつかの点で変化するようなイベントにアクセスするとしたら、アナログソルバはデジタルカーネルがデータを更新するかイベントを発生するときにデジタルソルバに再同期して戻らなければならない。
     | これはアナログソルバがデジタルソルバを先導するところではどこでも実装される。
   * つまり、離散から連続へのデータ転換と関係のあるオーバヘッドが存在する。


 【Mixed-Signal constructs of limited efficiency】
   * アナログやMixed-Siganlシミュレーションで使用することができ、総合的なシミュレーションスピードに大きな影響を持ついくつかの構造がある。
   * | 交差関数の標準的なアナログ値は、@(above(expr))と@(cross(expr,dir))である。
     | 過渡解析中のこれら両方の関数の演算は以下のように定義される：
   
     1. すべてのアナログtimestepで解いている間、式がそのtimestepをこえて適当な方向でゼロと交差しているかどうかを検討
     2. もしゼロと交差しているなら、挿入された波形がゼロと交差している場所の時間許容範囲と一定の電圧内に新しい点があるかどうかを検討
     3. もしステップが大きすぎたら、仕様書の許容範囲を満たすような適した時間点をとるためシミュレータは反復手段をとる
     
   * | crossやaboveイベントが起こるときはいつでも、実際に交差する閾値に十分近いステップをシミュレータが取れるようにVerilog-AMS言語は要求している。
     | モデル作成側からすると、時間点が収束するのを受け入れる前に解の並行解を要求したり、実行されるはずの公平に高価な演算は理解されなければならないが、シミュレータは正しい場所へただステップしているだけのように見える。
     | このため多数のcross/above命令文が含まれていると総合的なシミュレーションスピードが低下する可能性がある。
   * 減速限界のため、cross/aboveイベントを使用している間、許容範囲内の時間/電圧のわずかな値は関数で規定されなければならない。
     | わずかな許容誤差範囲値を規定することで、シミュレータは信号の別点の見積もりに十分な正確さを得てステップを戻ったり、時間のかかるステップに応じることができる。
     | @(above(V(in), 1n, 100m)) begin ...


   * | 完全問題の解のため、エッジの正確なタイミングは重要ではないことが多々ある。最初のアナログ時間点のイベントに取り組むにはたいていの場合、十分である。
     | このような場合、単純なif()式はtimestepの強制変換なしに閾値が交差しても動作するのに向いている。
     | if(V(in)>0 && Vlast<0) begin ...


   * | もしエッジの時間が正確に計測される必要があるなら、計測するためにポイントに戻ることなくゼロを横切る式の時間を与えることで返される標準関数のlast_crossing(expr,dir)がある。
     | Tcross = last_crossing(V(in), 1); ...


   * | もし@(cross())命令文が離散コードの内部で使用されていたら、アナログ値がゼロを横切るときのデジタルイベントを作るため、閾値の大数をつかむ必要があれば同様に分解された結果と共に、同じtimestep管理がアナログシミュレーションエンジンに適応される。
     | この場合、アナログ信号は離散と同様にうまくサンプリング演算を通して変換され、離散信号を扱う離散領域で計測を行う。
   * | サンプリング演算がいくつかの離散オーバーヘッドを加える間、アナログtimestep命令文は全く影響せず、アナログ信号にデジタルシミュレータが答える間、アナログシミュレータにフルスピードで続けることを許す。
     | 通常の時間ドメインサンプリングは単純な遅延ループと共に機能する
     | always #(Td) Vamp = V(in);


   * | 別のアプローチは、電圧/時間のトレイランスを与えられたアナログ信号の変化に基づいたイベントを生み出すabsdeltaという名前の関数を使う事である：
     | always @(absdelta(V(in), Vdelta, Ttol, Vtol)) Vsamp = V(in);


   * 一般に、自然に選ぶよりもかなり小さなtimestepをシミュレータに強いるどんなアナログ構造でも、シミュレーションを遅くするといえる。
   * | たとえば、アナログ遅延関数$absdelayは、入力から出力までのアナログ遅延を定義する。
     | 副作用としてシミュレータに仕様遅延サイズよりも小さなtimestepを強いる(よりよいアプローチは、ただ位相遅延の少量が必要とされるだけのアナログ遅延への一次近似である一次ローパスフィルタを使用すること)。
   * | 同様にtransition関数は入力変化に基づいた立上り遅延を持つ信号を定義する。
     | 小さなゼロではない遅延、もしくは小さな立上り遅延を規定することは、出力波形を正しく生成するために小さなtimestepを実行する変化を引き起こすかもしれない。
     | (解はゼロを使用され、できるだけ大きな立上り遅延がtimestepに与える影響を最小化する)
   * $bound_step関数は、より多くの解のなかのタイムポイントを強いることで、timestepのサイズの上限を実行するのに向いている。


   * 小さなtimestepはシミュレーション進度を減速させるだけでなく、将来的に多くのtimestepのための永続効果を持つ。
   * 良い数値精度を与える典型的なアナログシミュレータ演算子は、シミュレータによって小さなアナログtimestepがとられるときはいつでも各々連続して起こるtimestepが先行するtimestepの二倍以上はないということを要求する。
   * | もしシミュレータの典型的timestepサイズが2ns前後で、動作イベントが1psのtimestepを強いたとすると、次の2nsの結果を計算するために別の10のフルtimestep( 2ps, 4ps, 8ps, 16ps, ..., 1024psの増分で)を取らなければならない
     | 動作コードによって挿入されたただ一つのtimestepによってシミュレーション速度は十倍に減少する。
   * 結論としては、小さすぎるtimestepによる動作コードは大抵、小さなtimestepを強いないコードよりも遅いシミュレーションに終る。


Real Best Practice
-----------------------------------------------
 * | ブロック間を通るそれぞれの信号のためのデータ表現は、realモデルを定義するときに最も重要である。
   | 標準の表現は以下を含む:
  
   * Voltage (ハイインピーダンス負荷と仮定する)
   * Current (低インピーダンス負荷と仮定する)
   * Effective voltage (固定発生源、負荷インピーダンスの期待に基づく)
   * Electrical (ノード接続に基づいて実行される単純ん亜インピーダンス効果を考慮に入れる信号の電圧/電流関係をマップするいくつかの方法を使う)

 * 変化していることをどのように理解するかで決まる信号を表現するためのいくつかの方法がある：

   * Static (値はほぼ定数で、時々新しい値になる)
   * Updating (値は大抵変化していて、波形を追う必要があるときにはいつでも更新する)
   * Sampled (値は既知の定率で変化していて、離散点間を傾斜とみなすことができる)
  
 * | RNMのメカニズムはデジタルモデルと同等であり、違いは、データがビットやビットベクタというよりはむしろ実数の形をしているという点である。
   | システムレベルのテストによってそのモデルを使うよう強いられることが直接決まるモデリングより前に、リアルモデルで必要とされる精度を決めることが重要である。


 * どのタイプのアナログ信号フィルタリングを要求しないモデルは、入力の関数として出力を定義できる。
 * フィルタリングが要求される場合、信号より前の特定点で毎回値が変化する場所からは固定timestep標準フォーマットを持てるように、信号経路中のいくつかの点で標準化データ形式に最も単純に変換されることがある。
 * 基本Samplerの例は以下の通り。

    .. literalinclude:: ./txt/sampler.txt
      :linenos:
      :language: verilog

 * | 入力が定数にとどまっているとき、出力は特に小刻みに動く形式であることに注意する。
   | フィルタに元来の入力が変化しないときでさえ計算し続けることのように、この信号に基づくどのブロックもTs ns間隔のどのイベントでも値変化がみられる。


 * | その形式に変換することで、その階層の追加の時間依存のあるすべての演算は、入力が変化するそのたびに単純なデータ駆動型依存関係によって定義することができ、出力は新しい入力と前に格納されたいくつかの状態に基づいて再計算される。
   | これは、シーケンスのそれぞれのブロックを通して入力から出力へのフローを保持している。
 * サンプリング演算のオーダは制御できないので各ブロックでの独立したサンプリングを実行する試みは、予期せぬ遅延を生む。
 * | 不変timestep要件を実行しないフィルタリングは可能であるが、すべての可能性のあるケースを処理するためのオーバーヘッドが各ブロックのand/or複雑性で要求される。
   | たとえ入力が一定になったとしてもフィルタの出力は変化し続けなければならないためである。


 * | 他の一般的な再サンプリングアルゴリズムは、ダウンサンプリング(すべてのNth入力点から出力へと移動するだけのサンプルレートの低下)や、平均値に基づく再サンプリング(それぞれのサンプルサイクル時間を超えて入力信号を計算する)を含む。
   | 留意すべきは、サンプリング周波数の妥当な比次第で(平均値に基づく再サンプリングは)DCからの入力信号の周波数領域エネルギー含量を保持することができるということである。
 * | 更新時の入出力信号間のランダムオフセットを知らないと、周波数かジッタノイズがすべてのほかの形式に加えられる。
   | これにより、(パルス幅変調(PWM)入力信号のような)入力信号の正確なDCレベルを維持する必要があるなら、常に平均値に基づく方法を用いるべきである。
