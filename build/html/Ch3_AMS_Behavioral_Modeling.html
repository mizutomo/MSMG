<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ch.3 AMS Behavioral Modeling &mdash; Mixed-Signal Methodology Guide 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Mixed-Signal Methodology Guide 1.0 documentation" href="index.html" />
    <link rel="prev" title="Welcome to Mixed-Signal Methodology Guide’s documentation!" href="index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="index.html">Mixed-Signal Methodology Guide 1.0 documentation</a></div>
        <div class="rel">
          <a href="index.html" title="Welcome to Mixed-Signal Methodology Guide’s documentation!"
             accesskey="P">previous</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch-3-ams-behavioral-modeling">
<h1>Ch.3 AMS Behavioral Modeling<a class="headerlink" href="#ch-3-ams-behavioral-modeling" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Analog設計者は、これまでボトムアップ手法により設計を行なってきた。</li>
<li>複数のサブシステムを含んだシミュレーションを行うとき、Trレベルでは時間がかかるため、一部ブロック(特性として見る必要のないブロック)をビヘイビアモデルに置き換えるなど、シミュレーションの高速化のためだけに機能モデルを使用してきた。</li>
<li>このようなボトムアップアプローチは、対処療法的であり、プロジェクトの銀の弾丸ではない。</li>
<li>システム設計段階から、モデルによりスペックの検証を行うトップダウン設計に移行する必要がある。</li>
<li>トップダウン・アプローチを取ることで、Executable Spec(検証可能な仕様書)となる。</li>
</ul>
</div>
<div class="section" id="modeling-classifications">
<h2>Modeling classifications<a class="headerlink" href="#modeling-classifications" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>アナログの場合、決まった抽象度というものがない。また、デジタルと異なり、モデル開発をサポートするようなツールもほとんどないため、モデル作成にかかる時間が千差万別となる。</li>
<li>シミュレーション時間も、抽象度によって、大きく異る。</li>
<li>効率的なシミュレーションを行うためには、要求に応じた適切な抽象度・複雑度のモデルを用意する必要がある。</li>
<li>モデリングする際には、以下のことを考慮する必要がある。<ul>
<li>対象としているシミュレータがAnalog/Digital/Mixed-Signalを扱えるかどうか。</li>
<li>適切な階層(抽象)構造となっているか。</li>
<li>モデルにどこまでの特性を組み込むか。1次の線形特性か、非線形特性か。</li>
</ul>
</li>
<li>モデル化において重要なことは、モデルの使用目的を把握すること。</li>
<li>モデルの使用目的が把握できていないと、無駄に抽象度の低いモデルを作ったりしてしまう。</li>
</ul>
<div class="section" id="model-development">
<h3>Model Development<a class="headerlink" href="#model-development" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>モデルの複雑さは、どのレベルであっても要素の数に依存する。<ul>
<li>もし、ブロックが巨大なピン数を持っていた場合、リーズナブルなレベルまでブレークダウンさせる。</li>
<li>ただし、これ以上機能として分割できないようなレベルにまで落とし込むのは、機能モデルとしては適切ではない。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="design-topological-considerations">
<h3>Design Topological Considerations<a class="headerlink" href="#design-topological-considerations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>サブシステムへの分割の仕方は非常に重要である。</li>
<li>時には、常識が誤った方向に導くことがある。</li>
<li>通常、デジタル回路によって制御されるアナログ回路があった場合、2つのブロックに分けられがちである。</li>
<li>上記のように分けてしまうと、アナデジ間の制御信号の抽象度が非常に低くなるだけでなく、2つのモジュールがセットでないと、検証ができなくなる。</li>
<li>モジュールを一つにして、ブロック(always?)で分割するのがよい。</li>
</ul>
</div>
</div>
<div class="section" id="types-of-modeling">
<h2>Types of Modeling<a class="headerlink" href="#types-of-modeling" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>一般的に、大規模システムの検証に用いられる抽象度のレベルとしては、下記のものがあり、用途・目的に応じて、適切な使い分けが必要。<ul>
<li>Device based design(Spectre, SPICE): 回路図から生成されたネットリスト、もしくは、Pure SPICEで解釈可能なマクロモデルで記述されたネットリスト。</li>
<li>Analog modeling(Verilog-A): 電流/電圧の関係式を記述したモデル。アナログソルバ(SPICE)で解かれる。</li>
<li>Mixed-signal modeling(Verilog-AMS, VHDL-AMS): アナログ動作とデジタル動作が同時に記述可能なレベル。</li>
<li>Discrete real number modeling(Verilog-AMS, VHDL, SystemVerilog): 電気的な動作を実数の信号レベルに置き換えたモデル。インピーダンス効果(電流・電圧の関係式)は無視され、デジタルソルバで解かれる。</li>
<li>Logic modeling(Verilog, VHDL, SystemVerilog): 0,1,X,Zでモデリング。</li>
</ul>
</li>
</ul>
<div class="section" id="discrete-digital-modeling">
<h3>Discrete Digital Modeling<a class="headerlink" href="#discrete-digital-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>デジタルの入出力関係だけが記述されたモデル。デジタルソルバで解析。アナログ要素は含まない。</li>
<li>Verilog, VHDL, SystemVerilogで記述が可能。</li>
<li>アナログIPでもデジタルの入出力のみに着眼して、本レベルで記述されることがある。</li>
</ul>
</div>
<div class="section" id="continuous-analog-modeling">
<h3>Continuous Analog Modeling<a class="headerlink" href="#continuous-analog-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>システムの電気的特性が記述。言語は、Verilog-A。</li>
<li>電圧/電流の関係が記述。また、積分・微分オペレータも使用可能。</li>
<li>Verilog-Aモデルは、非線形常微分方程式に変換。他のSPICEコンポーネントと同様の方法でSPICEソルバにより解析。</li>
<li>Trレベルと比較して、10～50倍の高速化が可能。シミュレーションのスピードアップのためには、ノード数の削減と方程式数の削減が鍵。また、弱い非線型モデルにすることで、タイムステップを伸ばすことが可能。</li>
<li>デジタルの記述は全て電気的特性に変換され、SPICEソルバで実行される。そのため、論理シミュレータで解くよりも低速になる。また、IPCを用いたCo-Simで解析することも可能であるが、解析速度はアナログシミュレータのタイプステップに律速される。</li>
</ul>
</div>
<div class="section" id="mixed-signal-modeling">
<h3>Mixed-Signal Modeling<a class="headerlink" href="#mixed-signal-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Mixed-Signalに対応したシミュレータは、1つのカーネルで離散的なデジタル回路と連続的なアナログ回路を解くことができる。</li>
<li>Verilog-AMS, VHDL-AMSが記述に用いられる。</li>
<li>AMSでは、デジタルとアナログを自然にそれぞれの抽象度で記述することができる。また、データとイベントは相互に通信可能。</li>
</ul>
</div>
<div class="section" id="real-number-modeling">
<h3>Real Number Modeling<a class="headerlink" href="#real-number-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>電気的な信号を実数としてモデル化する手法。実数信号は、電圧もしくは電流のどちらかを表現するのに使用される。</li>
<li>RNMは、Verilog-AMS, SystemVerilog, VHDLで使用可能。</li>
<li>RNMは、デジタルソルバのみで解かれるため、SPICEと比べて1000～100万倍の高速化が可能。</li>
<li>双方向的なアナログの相関関係をモデリングすることはできない。</li>
</ul>
</div>
<div class="section" id="combined-approaches">
<h3>Combined Approaches<a class="headerlink" href="#combined-approaches" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">実際には、上記の抽象度のレベルを混ぜて使用されることが多い。</p>
</li>
<li><p class="first">例えば、RFレシーバの場合、下記の抽象度が混在で使用される。</p>
<blockquote>
<div><ul class="simple">
<li>RF信号パス: RNM</li>
<li>ベースバンド, バイアス、パワー供給: Electrical</li>
<li>制御回路: ロジック</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="basic-moeling-formats">
<h2>Basic Moeling Formats<a class="headerlink" href="#basic-moeling-formats" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">この本の目的は、4タイプの記述方法における長所・短所に対する洞察力をつけること。</div>
<div class="line">各記述方法における例(Programable-Gain Amplifier)を例に述べていく。</div>
</div>
<div class="section" id="model-operational-description">
<h3>Model Operational Description<a class="headerlink" href="#model-operational-description" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>差動入力、差動出力。出力には入力をゲイン倍した電圧が出力される。</li>
<li>ゲインは、デジタルの3bitバス入力(GAIN[2:0])。</li>
<li>実際のPGAにあるその他のピン(電源、バイアス入力、出力のEnable信号)あり。</li>
<li>出力は、(VDD-VSS)/2を中心とする。</li>
<li>出力端子の出力抵抗はRoutとする。</li>
</ul>
<blockquote>
<div><table border="1" class="docutils">
<caption>List of terminals</caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">pinName</th>
<th class="head">expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>INP,INM</td>
<td>差動入力 V(INP,INM)</td>
</tr>
<tr class="row-odd"><td>OUTP,OUTN</td>
<td>差動出力 V(OUTP,OUTN)</td>
</tr>
<tr class="row-even"><td>GAIN[2:0]</td>
<td>ゲイン制御端子( <a class="reference external" href="mailto:dbmin&#37;&#52;&#48;GAIN=000">dbmin<span>&#64;</span>GAIN=000</a>, <a class="reference external" href="mailto:dbmax&#37;&#52;&#48;GAIN=111">dbmax<span>&#64;</span>GAIN=111</a> )</td>
</tr>
<tr class="row-odd"><td>VDD,VSS</td>
<td>電源</td>
</tr>
<tr class="row-even"><td>VB</td>
<td>バイアス入力</td>
</tr>
<tr class="row-odd"><td>EN</td>
<td>Enable信号( ハイインピーダンス&#64;EN=0, 通常出力&#64;EN=1 )</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="ams-programmable-gain-amplifier-model">
<h3>AMS Programmable-Gain Amplifier Model<a class="headerlink" href="#ams-programmable-gain-amplifier-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_verilogams</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="n">electrical</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">;</span>
<span class="kt">logic</span> <span class="no">EN</span><span class="p">;</span>  <span class="kt">logic</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rout</span><span class="o">=</span><span class="mh">100</span><span class="p">;</span>        <span class="c1">// output resistance for each pin</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">10</span><span class="n">n</span><span class="p">;</span>          <span class="c1">// rise/fall time for gain &amp; enable changes</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>         <span class="c1">// terms in output calculation</span>
<span class="kt">real</span> <span class="n">Gout</span><span class="p">;</span>                      <span class="c1">// output conductance (smoothly switched)</span>
<span class="k">integer</span> <span class="n">Active</span><span class="p">;</span>                 <span class="c1">// flag for active operation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>

  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="n">analog</span> <span class="k">begin</span>
<span class="c1">// Check device is active (EN high, supply &amp; bias correct):</span>
  <span class="n">Active</span> <span class="o">=</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VB</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>
  <span class="n">Av</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="o">?</span> <span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">)</span><span class="o">:</span><span class="mh">1</span><span class="n">u</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="n">Tr</span><span class="p">);</span>                  <span class="c1">// convert to V/V</span>
  <span class="n">Voctr</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">)</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                         <span class="c1">// CM output level wrt Vss</span>
  <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                        <span class="c1">// max swing of output</span>
  <span class="n">Vodif</span> <span class="o">=</span> <span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">);</span>                              <span class="c1">// gain &amp; saturation limiting</span>

<span class="c1">// Driver output pins with differential Gain*input at Rout if active,</span>
<span class="c1">// high impedance if disabled, or high attenuation on bias error:</span>
  <span class="n">Gout</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="nl">Rout:</span><span class="mh">1</span><span class="n">n</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>

  <span class="no">I</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>
  <span class="no">I</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>

<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<div class="section" id="id1">
<h4>端子の属性定義<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>deciplines.vamsを定義 (/common/appl/Cadence/mmsim/12.1_isr2/linux/tools.lnx86/spectre/etc/ahdl/deciplines.vams)</li>
<li>アナログ信号(入出力、電源、バイアス入力)は、electricalで定義。analogブロック内で使われI(),V()を使用して測定。アナログソルバで解かれる。</li>
<li>デジタル信号(GAIN,EN)は、logicで定義。デジタルブロック内で使われ、1,0,X,Zの値を持つ。デジタルソルバで解かれる。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id2">
<h4>パラメータ定義<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>定義した数値はデフォルトで、後から変更可能。</li>
<li>Trは、スペックではない。ただし、ゲインとコンダクタを変える場合にランプ的に変更するのに使用する。設定しないと、アナログソルバでtime step errorが発生します。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id3">
<h4>内部変数定義<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>realとintegerは内部変数。</li>
<li>アナログブロックでもデジタルブロックでもどちらでも使用できるが、どちらか一方でしかアクセス出来ない。</li>
<li>アナログの場合はanalogブロック内でアップデートされ、デジタルの場合はinitialかalwaysブロック内でアップデートされる。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id4">
<h4>デジタルブロック<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li>initial文: Simulationの最初で計算される。</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>DBinc(GAINの1bit辺りのゲイン増加両)を計算。</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>always文: Sim中繰り返し計算される。</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>GAINの各Bitをexclusive-ORする事で、入力信号にXが含まれるかを確認する。</li>
<li>GAIN[2:0]にXが含まれる場合はAdb=-40を設定、含まれない場合は、Adb= dbmin+DBinc*GAINでゲインを計算。</li>
<li>&#64;(GAIN)が重要。これを入れることによって、always文の解析が次のGAIN信号が変化した時に評価されるようになる。これが無かったら、解析時間は0[sec]で止まってしまい永久ループとなってしまう。</li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>アナログブロック<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">Activeフラグは、EN信号と電源電圧、バイアス電圧で決定。</div>
<div class="line">電源電圧≧2.0[V]、バイアス電圧=0.7±0.05V[V]。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Avは、Adb(ゲイン)をdBから比率に変更したもの。</div>
<div class="line">Active=1の時に計算結果、Active=0の時は0.001とする。</div>
<div class="line">Adbの急激な変化によるtime step errorを防ぐためにtransition関数で立ち上がりにTrの時間を設けている。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Voctrは、コモン電圧で電源電圧の1/2。ただし、電源・バイアスを満たさない場合には供給されないため、Active信号で制御。</div>
<div class="line">Active信号は急峻に変化するため、transition関数で立ち上がりにTrの時間を設けている。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vomaxは、出力のpeak-to-peakの最大出力のため電源電圧で定義。ただし、電源電圧が供給されていない場合には、0.001[V]とする。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vodifは、差動出力の信号成分。</div>
<div class="line">入力差動信号をゲイン倍したものになるが、AMPの動作電圧で飽和する。</div>
<div class="line">min/maxで簡単に定義する事も出来るが、実回路特性に近づけるためtanh(ハイパーボリックタンジェント)関数を使用して緩やかにリミットがかかるようにした。</div>
</div>
</li>
</ul>
<img alt="Inputとoutputの関係" src="_images/vodif.png" />
<ul>
<li><div class="first line-block">
<div class="line">Goutは、出力コンダクタンス。</div>
<div class="line">EN=1の場合は1/Routだが、EN=0の場合は1/1GΩとなる。ENの2値の切換えにはtransition関数を使用する。</div>
<div class="line">(100Ωから0.1%の変化で1MΩに到達するためEN信号による切換えは直ぐに行われる。)</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">出力端子の電流/電圧の関係を示す。コントリビューション文(&lt;+)を使用する事で、分岐点における電流と電圧の関係をノード解析によって求める。</div>
<div class="line">出力電圧だけであれば、V(OUTP,VSS)&lt;+Voctr+Vodif/2;で示せるが、コンダクタンスを式に加える事で電流成分も表す。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="analog-pga-model">
<h3>Analog PGA Model<a class="headerlink" href="#analog-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_veriloga</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span> <span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>             <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>               <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>             <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>             <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                     <span class="c1">// output enable</span>
<span class="n">electrical</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">;</span>
<span class="n">electrical</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>      <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>      <span class="c1">// gain for VCVGA=111</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rout</span><span class="o">=</span><span class="mh">100</span><span class="p">;</span>      <span class="c1">// output resistance for each pin</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">10</span><span class="n">n</span><span class="p">;</span>        <span class="c1">// rise/fall time for gain &amp; enable changes</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>          <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>       <span class="c1">// terms in output calculation</span>
<span class="kt">real</span> <span class="n">Gout</span><span class="p">;</span>                    <span class="c1">// output conductance (smoothly switched)</span>
<span class="k">integer</span> <span class="n">Gint</span><span class="p">;</span>                 <span class="c1">// integer value from gain bus</span>
<span class="k">integer</span> <span class="n">Active</span><span class="p">;</span>               <span class="c1">// flag for active operation</span>

<span class="c1">// Macro to convert pin coltage to logic level of 1 or 0 based on half supply:</span>
<span class="cp">`define L(pin) (V(pin,VSS)&gt;V(VDD,VSS)/2)</span>

<span class="n">analog</span> <span class="k">begin</span>
<span class="c1">// Check when enabled &amp; biased properly:</span>
  <span class="n">Active</span> <span class="o">=</span> <span class="no">`L</span><span class="p">(</span><span class="no">EN</span><span class="p">)</span><span class="o">==</span><span class="mh">1</span> <span class="o">&amp;&amp;</span> <span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VB</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>

<span class="c1">// Gain calculation:</span>
  <span class="p">@(</span><span class="n">initial_step</span><span class="p">)</span> <span class="n">DBinc</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>            <span class="c1">// compute per-bit increment</span>
  <span class="n">Gint</span> <span class="o">=</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">2</span><span class="p">])</span><span class="o">*</span><span class="mh">4</span> <span class="o">+</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">1</span><span class="p">])</span><span class="o">*</span><span class="mh">2</span> <span class="o">+</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">0</span><span class="p">]);</span> <span class="c1">// get integer form of GAIN</span>
  <span class="n">Adb</span> <span class="o">=</span> <span class="n">dbmin</span> <span class="o">+</span> <span class="n">DBinc</span><span class="o">*</span><span class="n">Gint</span><span class="p">;</span>                           <span class="c1">// convert to gain in dB</span>
  <span class="n">Av</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="n">Active</span><span class="o">?</span> <span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">)</span><span class="o">:</span><span class="mh">1</span><span class="n">u</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>        <span class="c1">// to V/V or small if off</span>

<span class="c1">// Output signal evaluation:</span>
  <span class="n">Voctr</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">)</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                       <span class="c1">// CM output level wrt Vss</span>
  <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                      <span class="c1">// max swing of output</span>
  <span class="n">Vodif</span> <span class="o">=</span> <span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">);</span>                            <span class="c1">// gain &amp; saturation limiting</span>

<span class="c1">// Driver output pins with differential Gain*input at Rout if active,</span>
<span class="c1">// high impedance if disabled, or high attenuation on bias error:</span>
  <span class="n">Gout</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="no">`L</span><span class="p">(</span><span class="no">EN</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="nl">Rout:</span><span class="mh">1</span><span class="n">n</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>

  <span class="no">I</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>
  <span class="no">I</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>

<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>アナログモデルは、デジタルソルバが無い場合、又は全PINがアナログ端子として定義されている場合に使用され、VerilogAで記述される。</li>
<li>verilogAを使用(VerilogAMSの一部)</li>
<li>verilogAMSで示したアナログブロックと同じ物を使用できる。ただし、デジタル部は存在しない。</li>
</ul>
</div></blockquote>
<div class="section" id="id6">
<h4>端子の属性定義<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">全ピンはelectrical又はその他の連続系で定義される。（熱、磁力、一方向or循環システム等）</div>
<div class="line">ENとGAINがelectrical宣言されるのだけVerilogAMSと違い、他は同じ。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">離散数(値)は時間で変化する電圧波形としてモデル化⇒シミュレーション速度が遅くなる。</div>
<div class="line">各デジタル信号のH→L変化にtransition波形を使用するため、多くの解析ステップが必要で通常はシミュレーションスピードが遅くなる。</div>
<div class="line">本モデルでは、GAINはまれにしか動かないので、スピード的には問題にならない。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id7">
<h4>内部変数定義<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>VerilogAMSとほぼ同じ。ただし、全てアナログブロック内で使用。</li>
<li>[追加]Gint：GAINバス入力からinteger(0～7)の値を求めるのに使用。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id8">
<h4>マクロの追加<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">デジタルノードの電圧を変換するためのマクロ(`L())を追加</p>
</li>
<li><div class="first line-block">
<div class="line">アナログブロックで、1/2電源電圧をスレッショルドとしてデジタル信号を処理、</div>
<div class="line">条件分岐はTrueで1、falseで0を返す。</div>
</div>
</li>
<li><p class="first">マクロ定義する事で、複数個所の同じ処理を簡易化（コンパイル時の影響はなし）。</p>
</li>
<li><div class="first line-block">
<div class="line">例えば、EN信号のロジックレベル判定を`L(EN)と書く事で、V(EN,VSS)&gt;V(VDD,VSS)/2の結果に置換える。</div>
<div class="line">Activeフラグも同じ。</div>
</div>
</li>
<li><p class="first">デジタルブロックで定義されていたTrue/False判定は複数個所で実行されていたためマクロ化した。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id9">
<h4>アナログブロック<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">&#64;(initial_step)は、アナログシミュレーションの初期ステップで評価を実施する(デジタルinitialと同じ)。</div>
<div class="line">DBincをアナログブロック内で初期化するのに使用。</div>
</div>
</li>
<li><p class="first">GAINバスは、electricalノードから`L()マクロを使ってロジックレベルを検知し、0～7のintegerを返す。</p>
</li>
<li><p class="first">Adb(dbゲイン)はGintを元に計算され、Av(比率ゲイン)はAMSの場合と同じ評価式で計算される。</p>
</li>
<li><p class="first">残りのコードは、EN信号のロジックレベル判定以外はAMSと同じ。</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="real-pga-model">
<h3>Real PGA Model<a class="headerlink" href="#real-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_wrealmodel</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="n">wreal</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>         <span class="c1">// terms in output calculation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>
  <span class="n">Av</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">);</span>		<span class="c1">// convert to V/V</span>
  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="c1">// Check device is active (EN high, supply &amp; bias correct):</span>
  <span class="kt">wire</span> <span class="n">Active</span> <span class="o">=</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="o">&gt;=</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">VB</span><span class="o">-</span><span class="no">VSS</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>
  <span class="k">always</span> <span class="k">begin</span>
    <span class="n">Voctr</span> <span class="o">=</span> <span class="n">Active</span><span class="o">*</span><span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                        			<span class="c1">// CM output level wrt Vss</span>
    <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                        <span class="c1">// max swing of output</span>
    <span class="p">@(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="n">Active</span><span class="p">);</span>							<span class="c1">// repeat when supplies change</span>
  <span class="k">end</span>

<span class="c1">// define saturation limiting &amp; high attenuation when inactive:</span>
  <span class="k">always</span> <span class="p">@(</span><span class="o">*</span><span class="p">)</span> <span class="n">Vodiff</span> <span class="o">=</span><span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="p">(</span><span class="no">INP</span><span class="o">-</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Active</span><span class="o">?</span> <span class="mh">1</span><span class="o">:</span><span class="mf">1e-6</span><span class="p">);</span>

<span class="c1">// output the differential real signal if actively biased;</span>
<span class="c1">// high impedance if not enabled, otherwise X output:</span>

  <span class="k">assign</span> <span class="no">OUTP</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="no">`wrealZstate</span><span class="o">:</span> <span class="no">`wrealXstate</span><span class="p">;</span>
  <span class="k">assign</span> <span class="no">OUTN</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="n">Voctr</span><span class="o">-</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="no">`wrealZstate</span><span class="o">:</span> <span class="no">`wrealXstate</span><span class="p">;</span>

<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">Real numberモデルはデジタルソルバで実行される。</p>
</li>
<li><p class="first">AMSモデルのデジタルブロックは再利用。アナログブロックのみ書き直しとする。</p>
</li>
<li><div class="first line-block">
<div class="line">アナログソルバを含まないため、負荷インピーダンスの影響はモデル化出来ない。</div>
<div class="line">出力は、負荷抵抗を無視した実際の電圧で定義される。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">wrealタイプ(VerilogAMSサポート)：</div>
<div class="line">64bitのreal numberとして認識し、ブロック間のデジタル値として用いられる。</div>
<div class="line">bitやバスとは違い実数として解釈される。</div>
</div>
</li>
</ul>
</div></blockquote>
<div class="section" id="id10">
<h4>端子の属性定義<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>ピンは全てwreal定義</li>
<li>注意：wrealはdisciplineではなく、単なるシグナルタイプ。デフォルトは、logicのdiscipline。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id11">
<h4>内部変数の定義<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>出力抵抗が不要になったのと、値の変化に立ち上がり時間がなくなるためRoutとTrは不要。</li>
<li>Activeはintegerとして定義する必要がなくなり、内部ピンとして定義される。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id12">
<h4>デジタルブロック<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">verilogAMSのデジタルブロックはそのまま。</p>
</li>
<li><p class="first">verilogAMSのアナログブロックをデジタル処理として置き換える。</p>
</li>
<li><div class="first line-block">
<div class="line">veriloaでは、ピンと変数で2つの異なるメカニズムがある。</div>
<div class="line">変数：real, integer又はregで宣言され、always又はinitialブロックで定義される。</div>
<div class="line">ピン：wire(又はwreal)宣言され、wireはassign文によって制御される。</div>
</div>
</li>
<li><p class="first">wire Active=...は、制御のために内部pinとして定義。式の結果が変化した時にActiveの値がアップデートされる。</p>
</li>
<li><div class="first line-block">
<div class="line">alwaysブロックは、コモンモードと最大振幅値計算に使用。</div>
<div class="line">電源又はActiveフラグの変化時に計算される。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vodiff(出力電圧差)の記述はalwaysブロックで表現。</div>
<div class="line">ただし、この場合は&#64;(*)をブロックに追加する事で、全変数のいずれかが変更された場合に計算されるようにしている。</div>
<div class="line">always &#64;(*)は、always &#64;(Vomax, Av, INP, INN, Active)。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">標準のデジタルピンは出力状態としてX(unkown)とZ(high impedance)をサポートする。</div>
<div class="line">しかし、VerilogAMS言語の仕様はこれらの表現を含まないため、代わりに`wrealXstate、`wrealZstateを使用する。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">出力ピン(OUTP,OUTN)はActiveとEN信号によって制御される。</div>
<div class="line">しかし、Z状態とX状態があるため、直接wreal型のピンにドライブする事ができないのでassign文で記述する。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="digital-pga-model">
<h3>Digital PGA Model<a class="headerlink" href="#digital-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_verilog</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="c1">// note that all the signals are just digital here - no analog contet.</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>
  <span class="n">Av</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">);</span>		<span class="c1">// convert to V/V</span>
  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="c1">// Check if EN=1, VDD=1, VSS=0, VB=1, and GAIN bits are all valid:</span>
  <span class="kt">wire</span> <span class="n">Active</span> <span class="o">=</span> <span class="p">({</span><span class="no">EN</span><span class="p">,</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">}</span><span class="o">===</span><span class="mh">4&#39;b1101</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">!==</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">);</span>

<span class="c1">// Pass input to output if active; high impedance when disabled,</span>
<span class="c1">// any other case output goes to invalid:</span>
  <span class="k">assign</span> <span class="no">OUTP</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="no">INP</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bz</span> <span class="o">:</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>
  <span class="k">assign</span> <span class="no">OUTN</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="no">INN</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bz</span> <span class="o">:</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>

<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><div class="first line-block">
<div class="line">純粋なデジタルSimが要求される時や、</div>
<div class="line">アナデジ間のインターフェースをチェックする目的でのみMixed=Signalブロックが含まれる場合に使われる。</div>
</div>
</li>
<li><p class="first">Simにおけるアナログのオペレーションはブラックボックス扱い。</p>
</li>
<li><p class="first">アナログ信号は、H/L信号で表現される。また、受け付けない場合はX、オフした時はZに遷移する。</p>
</li>
<li><p class="first">ブロックの制御特性は内部で計算されるが、それらの値はテストベンチからのダイレクトアクセスか、プロットによる保存によってのみ測定可能。</p>
</li>
<li><div class="first line-block">
<div class="line">デジタルのPGAに対する典型的なアプローチは、</div>
<div class="line">H入力をポジティブ電源(VDD=1)に、L入力をネガティブ電源(VSS=0)にする。</div>
<div class="line">バイアスインプット可能をVB=1とする。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">変換特性は、入力信号を出力信号にそのまま通す。</div>
<div class="line">適切にバイアスされている場合、OUTP=INP, OUTN=INN。</div>
<div class="line">バイアスされていない場合、出力端子はHighインピーダンス(1&#8217;bz)になる。</div>
<div class="line">供給電源が来ていない場合は、unkown状態(1&#8217;bx)となる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">ゲインはデジタルセグメントとして計算される。</div>
<div class="line">ただし、単なる内部のreal変数であり、変換特性には影響しない。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="additional-model-coding-examples">
<h2>Additional Model Coding Examples<a class="headerlink" href="#additional-model-coding-examples" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">このセクションでは以下の四つのモデリングアプローチそれぞれを用いて、Verilog-AMSの代表的なモデルを示す。</div>
</div>
<blockquote>
<div><ul class="simple">
<li>Dフリップフロップのデジタルモデル</li>
<li>オペアンプのアナログモデル</li>
<li>ADコンバータのAMSモデル</li>
<li>離散時間ローパスフィルタのRNモデル</li>
</ul>
</div></blockquote>
<div class="section" id="digital-verilog-d-type-flip-flop">
<h3>Digital: Verilog D-type Flip Flop<a class="headerlink" href="#digital-verilog-d-type-flip-flop" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first">Verilog言語は論理的関係性を定義</p>
</li>
<li><p class="first">ここでは標準Verilogフォーマットによって書かれたD-FFモデルを例に述べる</p>
</li>
<li><div class="first line-block">
<div class="line">この例では入力Clockのエッジを読み込み、出力Qにはデータ入力が読み込まれ通される</div>
<div class="line">出力Qbは常に出力Qの補出力である</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">モデルは非同期リセット式</div>
<div class="line">ResetがhighのときはいつでもQは0になる</div>
</div>
</li>
<li><p class="first">以下にD-FFの簡単な記述を示す</p>
</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="no">DFF1</span> <span class="p">(</span><span class="no">Q</span><span class="p">,</span> <span class="n">Qb</span><span class="p">,</span> <span class="n">Data</span><span class="p">,</span> <span class="n">Clock</span><span class="p">,</span> <span class="n">Reset</span><span class="p">);</span>     <span class="c1">// name of module, list of pins</span>
   <span class="k">output</span> <span class="no">Q</span><span class="p">,</span><span class="n">Qb</span><span class="p">;</span>                              <span class="c1">// nomal and inverted output</span>
   <span class="k">input</span>  <span class="n">Data</span><span class="p">,</span><span class="n">Clock</span><span class="p">,</span><span class="n">Reset</span><span class="p">;</span>                  <span class="c1">// data in, clock, asynch reset</span>
   <span class="kt">reg</span>    <span class="no">Q</span><span class="p">,</span>                                 <span class="c1">// register for output signal to drive</span>
   <span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">Clock</span> <span class="k">or</span> <span class="k">posedge</span> <span class="n">Reset</span><span class="p">)</span>  <span class="c1">// when clock or reset fo high</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Reset</span><span class="p">)</span> <span class="no">Q</span> <span class="o">=</span> <span class="mh">1&#39;b0</span><span class="p">;</span>                   <span class="c1">// if reset is high, output goes zero</span>
      <span class="k">else</span>       <span class="no">Q</span> <span class="o">=</span> <span class="n">Data</span><span class="p">;</span>                   <span class="c1">// otherwise on clock edge get data</span>
   <span class="k">assign</span> <span class="n">Qb</span> <span class="o">=</span> <span class="o">~</span><span class="no">Q</span><span class="p">;</span>                           <span class="c1">// degine notQ output to be inverse of Q</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">Q出力はClockかResetの立上りエッジで更新される</p>
</li>
<li><div class="first line-block">
<div class="line">Qbノードの更新はQ信号の反転と同等の値が連続的に保たたれるように代入文を使用される</div>
<div class="line">動作コードによって駆動していないため、Qbはreg宣言されない</div>
</div>
</li>
<li><p class="first">以下にD-FFの動作をチェックする簡単なテストベンチを示す</p>
</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ps</span>
<span class="k">module</span> <span class="no">DFF_TB</span><span class="p">;</span>
   <span class="kt">reg</span> <span class="no">D</span><span class="o">=</span><span class="mh">1</span><span class="p">,</span><span class="no">CK</span><span class="o">=</span><span class="mh">0</span><span class="p">,</span><span class="no">RST</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
   <span class="no">DFF1</span> <span class="no">DUT</span><span class="p">(.</span><span class="no">Q</span><span class="p">(</span><span class="no">Q</span><span class="p">),</span> <span class="p">.</span><span class="n">Qb</span><span class="p">(</span><span class="no">QB</span><span class="p">),</span> <span class="p">.</span><span class="n">Data</span><span class="p">(</span><span class="no">D</span><span class="p">),</span> <span class="p">.</span><span class="n">Clock</span><span class="p">(</span><span class="no">CK</span><span class="p">),</span> <span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="no">RST</span><span class="p">));</span>
   <span class="k">always</span> <span class="p">#</span><span class="mh">5</span> <span class="no">CK</span> <span class="o">=</span> <span class="o">~</span><span class="no">CK</span><span class="p">;</span>
   <span class="k">initial</span> <span class="k">begin</span>
      <span class="p">#</span><span class="mh">13</span> <span class="no">D</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">15</span> <span class="no">D</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">10</span> <span class="no">RST</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">10</span> <span class="no">RST</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">22</span> <span class="nb">$stop</span><span class="p">;</span>
   <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">DFF_TBは外部ピンが必要とされないシミュレーションのトップレベルのテストベンチモジュール</p>
</li>
<li><p class="first">DFF1モジュールはインスタンスDUTとしてインスタンス化され、Clockへ100MHzのパルス波を打ち込み、そしてDataとResetを数度変化させることで期待通りにブロックが動作するかの検証を行い、モジュールではこれらで駆動する信号とレジスタを定義する</p>
</li>
<li><p class="first">留意すべきは、離散timescaleはこのテストベンチモジュールのために規定されているということである</p>
</li>
<li><div class="first line-block">
<div class="line">すべての離散およびミックスドシグナルのVerilogブロックは、離散時間のためのresolutionとtime unitを定義するために複数のtimescaleを利用する</div>
<div class="line">ここで示したようにモジュールに、標準includeファイル内で、コンパイラオプションで、など定義場所問わない</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">システム内で遅延定義のために#演算子を用いている</div>
<div class="line">モジュール固有の演算子(この場合は#)はここで定義するためにtime unitを必要とする</div>
<div class="line">このケースではtime unitはnsで定義され、#5は5nsを示す</div>
</div>
</li>
<li><p class="first">モジュールがあらゆるところで一貫して定義されるように、プロジェクトのtimescaleとresolutionを定めなければならないことに注意</p>
</li>
<li><p class="first">一般的に、(もっとも一般的に1nsか1psの時間単位)デジタルモデルの標準的な実行と、(システム速度に応じて1nsから1asにわたる)プロジェクト条件に基づいてきまるresolutionによって選ばれる。</p>
</li>
<li><p class="first">DFF1_TBモジュールのシミュレーション波形結果を以下に示す</p>
</li>
</ul>
<div class="figure">
<a class="reference internal image-reference" href="_images/fig4.png"><img alt="_images/fig4.png" src="_images/fig4.png" /></a>
</div>
<ul class="simple">
<li>Qは初期値を設定していないため、Data入力がassignされるClockの最初の立上りエッジまでは不定値(X)であることに注意</li>
<li>DataがHigh/Lowに変化すると、次のClockの立上りエッジでQの値が変化する</li>
<li>ResetがHighになるとすぐにQはLowになり、ResetがHighの間はClockが叩かれてDataの値が変化してもQには影響しない</li>
<li>Resetが解放されると、次のClockの立上りエッジで再びDataの値をQへと伝搬させる</li>
<li>Qbは常にQの反転である</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="analog-verlog-a-operational-amplifier">
<h3>Analog: Verlog-A Operational Amplifier<a class="headerlink" href="#analog-verlog-a-operational-amplifier" title="Permalink to this headline">¶</a></h3>
<p>このセクションでは、Verilog-Aの例として、OpAmpを解説。</p>
<blockquote>
<div><ul>
<li><p class="first">アナログビヘイビアモデルの設計は、ピンの入力と出力の電圧・電流の関係(線形性、非線形性、積分関係、微分関係)に着目して、モデリングを行う。</p>
</li>
<li><p class="first">また、入出力のピンだけでなく、内部変数を用いて、時間依存の関係は、離散的なイベントの処理を行い、出力信号は、入力信号値や内部変数値の関係で記述される。</p>
</li>
<li><p class="first">単一の特性だけでなく、一つのモデルで複数の特性を表現することがある。</p>
</li>
<li><p class="first">ここでは、以下の特性を持ったアンプのモデルを例として説明する。</p>
<ul class="simple">
<li>DCゲイン</li>
<li>オフセット</li>
<li>クリッピング</li>
<li>出力インピーダンス</li>
<li>ポールの周波数特性</li>
</ul>
</li>
<li><p class="first">このようなモデルを開発する際には、先に等価回路を導く必要がある。その後、そのトポロジをモデルに書き下す。</p>
</li>
<li><p class="first">オペアンプの等価回路を下記図に示す。</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/opamp_circuit.png"><img alt="_images/opamp_circuit.png" src="_images/opamp_circuit.png" /></a>
</div>
<ul class="simple">
<li>Icur: 入力差(inp, inm)に応じて、電流値を出力する電圧制御電流源(VCCS)。出力段をドライブする。Icurは、Rresに流れ、DCゲインを生成する。</li>
<li>Vctr: 入力差が0の場合、電圧源Vctrが、DC出力電圧を電源電圧の中間値になるように調整する。</li>
<li>Ccap: ポール位置の調整をするための容量。</li>
<li>Ilim: 非線形電流源。内部ノードNが供給電源以上にならないように、電流をシャントする。ダイオードによるリミッタの働き。</li>
<li>Rout: 付加的な出力抵抗。DC的には、出力抵抗は、RoutとRresの合成抵抗となるが、AC的には、容量CcapとIlimによる低インピーダンスの経路の存在により、ノードNがほぼグラウンドにショートされる。そのため、出力抵抗は、Routとなる。</li>
</ul>
</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="n">Amp1</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">inm</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">vdd</span><span class="p">,</span> <span class="n">vss</span><span class="p">);</span>
  <span class="k">input</span> <span class="n">inp</span><span class="p">,</span> <span class="n">inm</span><span class="p">,</span> <span class="n">vdd</span><span class="p">,</span> <span class="n">vss</span><span class="p">;</span>
  <span class="k">output</span> <span class="n">out</span><span class="p">;</span>

  <span class="n">electrical</span> <span class="n">inp</span><span class="p">,</span> <span class="n">inm</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">vdd</span><span class="p">,</span> <span class="n">vss</span><span class="p">,</span> <span class="no">N</span><span class="p">;</span>

  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Gain</span> <span class="o">=</span> <span class="mh">1</span><span class="n">k</span><span class="p">;</span>   <span class="c1">// DC gain (V/V)</span>
  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Vio</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>     <span class="c1">// input offset (V)</span>
  <span class="k">parameter</span> <span class="kt">real</span> <span class="no">GBW</span> <span class="o">=</span> <span class="mh">10</span><span class="no">M</span><span class="p">;</span>   <span class="c1">// Gain-Bandwidth product (Hz)</span>
  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rdc</span> <span class="o">=</span> <span class="mh">300</span><span class="p">;</span>   <span class="c1">// DC output resistance (ohms)</span>
  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rac</span> <span class="o">=</span> <span class="mh">100</span><span class="p">;</span>   <span class="c1">// AC &amp; Sat output resistance (ohms)</span>

  <span class="kt">real</span> <span class="n">Gm</span><span class="p">,</span> <span class="n">Rres</span><span class="p">,</span> <span class="n">Ccap</span><span class="p">,</span> <span class="n">Vnom</span><span class="p">;</span>  <span class="c1">// internal variables;</span>

  <span class="c1">// Macro for diode-like exponential dependence between voltae &amp; current:</span>
  <span class="c1">// Returns current of isat when voltage is zero, and decreases by</span>
  <span class="c1">// a factor of 100 for each dV decrease of input voltage:</span>
<span class="cp">  `define fclip(V, isat, dV) isat*exp(4.6*(V)/(dV))</span>

  <span class="n">analog</span> <span class="k">begin</span>
    <span class="p">@(</span><span class="n">initial_step</span><span class="p">)</span> <span class="k">begin</span>                 <span class="c1">// constants computed at startup</span>
      <span class="n">Rres</span> <span class="o">=</span> <span class="n">Rdc</span> <span class="o">-</span> <span class="n">Rac</span><span class="p">;</span>                   <span class="c1">// inner resistor value</span>
      <span class="n">Gm</span> <span class="o">=</span> <span class="n">Gain</span> <span class="o">/</span> <span class="n">Rres</span><span class="p">;</span>                   <span class="c1">// input transconductance</span>
      <span class="n">Ccap</span> <span class="o">=</span> <span class="mh">1</span> <span class="o">/</span> <span class="p">(</span><span class="no">`M_TWO_PI</span> <span class="o">*</span> <span class="no">GBW</span> <span class="o">/</span> <span class="n">Gm</span><span class="p">);</span>  <span class="c1">// capacitor to get specified GBW</span>
    <span class="k">end</span>

    <span class="c1">// Contributions of current for each branch in the topology diagram:</span>
    <span class="no">I</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="o">-</span><span class="no">GM</span> <span class="o">*</span> <span class="no">V</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">inm</span><span class="p">);</span>       <span class="c1">// transconductance from input</span>
    <span class="no">I</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span> <span class="o">-</span> <span class="no">V</span><span class="p">(</span><span class="n">vdd</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">Rres</span><span class="p">;</span>    <span class="c1">// resistor equation: I=V/R</span>
    <span class="no">I</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="n">ddt</span><span class="p">(</span><span class="n">Ccap</span> <span class="o">*</span> <span class="no">V</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">));</span>   <span class="c1">// capacitor equation: I=d(CV)/dT</span>
    <span class="no">I</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="no">`fclip</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">vdd</span><span class="p">),</span> <span class="mh">1</span><span class="p">,</span> <span class="mh">40</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="no">`fclip</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="n">vss</span><span class="p">,</span> <span class="no">N</span><span class="p">),</span> <span class="mh">1</span><span class="p">,</span> <span class="mh">40</span><span class="n">m</span><span class="p">);</span>   <span class="c1">// top&amp;bottom parts of limiter</span>
    <span class="no">I</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="no">V</span><span class="p">(</span><span class="no">N</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="o">/</span> <span class="n">Rac</span><span class="p">;</span>         <span class="c1">// series resistance on output</span>
  <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">モデルの正しさを検証するために、テストベンチを作成する。</p>
</li>
<li><p class="first">Verilog-Aモデルの場合、回路図作成環境でテストベンチを作成し、様々な条件下でいくつかのシミュレーションを実行する。</p>
</li>
<li><p class="first">アンプの場合、閉ループ特性、開ループ特性、線形動作領域、飽和動作領域の検証をDC/AC/Tran解析を用いて行う。</p>
</li>
<li><p class="first">下図にテストベンチを示す。このテストベンチでは、フィードバック抵抗をR1, RFでパラメータ化しており、このパラメータ値を調整することで、開ループ/閉ループを切り替える。</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/opamp_testbench.png"><img alt="_images/opamp_testbench.png" src="_images/opamp_testbench.png" /></a>
</div>
</li>
<li><p class="first">DCスイープシミュレーションの結果を下図に示す。この解析では、特に、線形領域と飽和領域の連続性を検証することができる。また、閉ループ特性を検証することで、フィードバックループが存在している場合のモデルの収束性を検証することもできる。</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/opamp_dc.png"><img alt="_images/opamp_dc.png" src="_images/opamp_dc.png" /></a>
</div>
</li>
<li><p class="first">AC解析は、周波数応答を検証するために使用される。</p>
</li>
<li><p class="first">開ループ特性では、小信号ゲイン、コーナー周波数、位相の関係を検証することができる。</p>
</li>
<li><p class="first">閉ループ特性では、フィードバックループに依り、ゲイン特性と位相特性が望ましい値になっているかを検証できる。</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/opamp_ac.png"><img alt="_images/opamp_ac.png" src="_images/opamp_ac.png" /></a>
</div>
<ul class="simple">
<li>テキスト通りの開ループ特性を得るためには、リミッタ電流源を無効にしなければいけなかった。</li>
</ul>
</li>
<li><p class="first">Tran解析では、ステップ入力をアンプに加えることで、線形性と非線形性の直接の関係を見ることができる。</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/opamp_tran.png"><img alt="_images/opamp_tran.png" src="_images/opamp_tran.png" /></a>
</div>
</li>
<li><p class="first">上記の例では、±100mVをゲイン1の設定に対して、加えた場合、出力は完全に入力に追随している。</p>
</li>
<li><p class="first">ゲインを10に設定した場合、出力は10倍になるが、応答はそれほど速くはならない。また、開ループの応答は、決まったスリューレートに制約されているが、電源電圧付近に達すると飽和してしまう。</p>
</li>
<li><p class="first">テストベンチを回路図で書くことが、ベストか?</p>
</li>
<li><p class="first">Verilog-A/Verilog-AMSのネットを使用して、テストシーケンスをファイルに書き、また、特性の測定も記述することができる。</p>
</li>
<li><p class="first">AC解析と同じ結果を見るためには、回路をsin波でドライブし、出力の振幅と波形のズレを観測すればよい。この方法により、シミュレーション時間は増大するが、再利用性が高まる。</p>
</li>
<li><p class="first">テストベンチをテキストで書くことで、多数の条件を一度のシミュレーションで実行し、かつ、結果のインスペクションが可能となる。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="mixed-signal-verilog-ams-digital-to-analog-converter">
<h3>Mixed-signal: Verilog-AMS Digital to Analog Converter<a class="headerlink" href="#mixed-signal-verilog-ams-digital-to-analog-converter" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">A digital to analog converter(DAC)の記述</p>
</li>
<li><p class="first">本モデルの第一の入力はデジタルのバス入力である</p>
</li>
<li><p class="first">入力が変化すると、出力電圧は参照電圧の比率として計算された電圧となる</p>
</li>
<li><p class="first">離散信号によって制御されたアナログ出力を定義するときは注意が必要</p>
</li>
<li><p class="first">アナログ出力がある値から別の値へ離散的な変化をするならば、重大な数の問題が起き、シミュレーションがスローダウンするか、収束エラーが起きる</p>
</li>
<li><p class="first">離散的に変化する量は、階段変化をランプ波形等の連続波形に変換しなければならない。</p>
</li>
<li><p class="first">本モデルでは離散的な変化に対しtransition filterを適用する</p>
</li>
<li><p class="first">デジタル入力の有効性(不定値)がチェックされなければならない。</p>
</li>
<li><p class="first">本モデルではイリーガルなバス値のときに出力電圧を0としている</p>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">DAC6</span> <span class="p">(</span><span class="n">Din</span><span class="p">,</span><span class="n">Aout</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">);</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">5</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">Din</span><span class="p">;</span>          <span class="c1">// digital input bus</span>
<span class="k">output</span> <span class="n">Aout</span><span class="p">;</span>              <span class="c1">// analog output</span>
<span class="k">input</span> <span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">;</span>            <span class="c1">// reference supply for output</span>
<span class="n">electrical</span> <span class="n">Aout</span><span class="p">,</span><span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">tr</span><span class="o">=</span><span class="mh">10</span><span class="n">n</span><span class="p">;</span>    <span class="c1">// (sec) risetime for output changes</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">rout</span><span class="o">=</span><span class="mh">1</span><span class="n">k</span><span class="p">;</span>   <span class="c1">// (ohms) output resistance</span>
<span class="kt">real</span> <span class="n">kout</span><span class="p">;</span>                <span class="c1">// output as fraction of supply</span>
<span class="kt">real</span> <span class="n">vout</span><span class="p">;</span>                <span class="c1">// continous analog output voltage</span>

<span class="k">always</span> <span class="k">begin</span>
 <span class="k">if</span> <span class="p">(</span><span class="o">^</span><span class="n">Din</span> <span class="o">===</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">)</span> <span class="n">kout</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span> <span class="c1">// if any bits invalid in Din, output is zero</span>
 <span class="k">else</span> <span class="n">kout</span> <span class="o">=</span> <span class="n">Din</span><span class="o">/</span><span class="mf">63.0</span><span class="p">;</span>      <span class="c1">// else compute scale factor for output</span>
 <span class="p">@(</span><span class="n">Din</span><span class="p">);</span>                    <span class="c1">// repeat whenever Din changes</span>
<span class="k">end</span>

<span class="n">analog</span> <span class="k">begin</span>
 <span class="n">vout</span> <span class="o">=</span> <span class="no">V</span><span class="p">(</span><span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span><span class="o">*</span><span class="n">transition</span><span class="p">(</span><span class="n">kout</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">tr</span><span class="p">,</span><span class="n">tr</span><span class="p">);</span> <span class="c1">// ramp to fraction of supply</span>
 <span class="no">I</span><span class="p">(</span><span class="n">Aout</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="n">Aout</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span><span class="o">-</span><span class="n">vout</span><span class="p">)</span><span class="o">/</span><span class="n">rout</span><span class="p">;</span>     <span class="c1">// drive output voltage+resistance</span>
<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">DACテストのテストベンチはVerilog-AMSでシンプルに記述される</p>
</li>
<li><p class="first">ひとつのinitialブロック内に離散値とアナログのスティミュラスを記述し、
シーケンシャルな変数リストと、次の値へ変化するまでの時間とで構成される</p>
</li>
<li><p class="first">最後の数行に、入力が無効になったときと供給電圧値が変化したときの出力テストがある</p>
</li>
<li><p class="first">これはブロックレベルでのビヘイビアモデル検証で含むべき標準的なチェックである</p>
</li>
<li><p class="first">典型的な入力だけでなく、期待されない入力時のモデルのファンクションを適切にチェックできる</p>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="no">DAC6_TB</span><span class="p">;</span>
<span class="n">electrical</span> <span class="n">Aout</span><span class="p">,</span><span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">;</span>            <span class="c1">// analog pins</span>
<span class="kt">real</span> <span class="n">Vsup</span><span class="p">,</span><span class="n">Vgnd</span><span class="p">,</span><span class="n">Tr</span><span class="p">;</span>                  <span class="c1">// control variables to drive analog supplies</span>
<span class="kt">reg</span> <span class="p">[</span><span class="mh">5</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">Din</span><span class="p">;</span>                      <span class="c1">// digital input bus</span>

<span class="no">DAC6</span> <span class="no">DUT</span><span class="p">(</span><span class="n">Din</span><span class="p">,</span><span class="n">Aout</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">);</span>        <span class="c1">// instanciate the digital to analog converter</span>

<span class="n">analog</span> <span class="k">begin</span>                        <span class="c1">// analog drive description</span>
 <span class="no">V</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="n">transition</span><span class="p">(</span><span class="n">Vsup</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>   <span class="c1">// drive the analog supplies</span>
 <span class="no">V</span><span class="p">(</span><span class="n">Vss</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="n">transition</span><span class="p">(</span><span class="n">Vgnd</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>   <span class="c1">// using the control variables</span>
<span class="k">end</span>

<span class="k">initial</span> <span class="k">begin</span>                       <span class="c1">// This is the sequential test procedure</span>
 <span class="n">Din</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>                             <span class="c1">// Initialize digital input bus to zero</span>
 <span class="n">Vsup</span><span class="o">=</span><span class="mh">3</span><span class="p">;</span> <span class="n">Vgnd</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>                    <span class="c1">// Initial 3 volt supply and ground voltage</span>
 <span class="n">Tr</span><span class="o">=</span><span class="mh">200</span><span class="n">n</span><span class="p">;</span>                           <span class="c1">// risetime for supply changes</span>
 <span class="k">repeat</span><span class="p">(</span><span class="mh">63</span><span class="p">)</span> <span class="p">#</span><span class="mh">50</span> <span class="n">Din</span><span class="o">=</span><span class="n">Din</span><span class="o">+</span><span class="mh">1</span><span class="p">;</span>          <span class="c1">// step Din thru all codes, incrementing every 50ns</span>
 <span class="p">#</span><span class="mh">100</span> <span class="n">Din</span><span class="o">=</span><span class="mh">8&#39;b100000</span><span class="p">;</span>                <span class="c1">// step to half scale input</span>
 <span class="p">#</span><span class="mh">100</span> <span class="n">Din</span><span class="o">=</span><span class="mh">8&#39;b10</span><span class="n">xx00</span><span class="p">;</span>                <span class="c1">// check response for X input</span>
 <span class="p">#</span><span class="mh">100</span> <span class="n">Din</span><span class="o">=</span><span class="mh">8&#39;b100000</span><span class="p">;</span>                <span class="c1">// back to half scale</span>
 <span class="p">#</span><span class="mh">100</span> <span class="n">Vsup</span><span class="o">=</span><span class="mf">2.4</span><span class="p">;</span>                     <span class="c1">// Check that output follows supply midpoint</span>
 <span class="p">#</span><span class="mh">300</span> <span class="n">Vsup</span><span class="o">=</span><span class="mf">3.0</span><span class="p">;</span>
 <span class="p">#</span><span class="mh">300</span> <span class="n">Vgnd</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>                     <span class="c1">// Check that it follows negative reference too</span>
 <span class="p">#</span><span class="mh">300</span> <span class="n">Vgnd</span><span class="o">=</span><span class="mh">00</span><span class="p">;</span>
 <span class="p">#</span><span class="mh">300</span> <span class="nb">$stop</span><span class="p">;</span>                        <span class="c1">// done with testing</span>
<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<a class="reference internal image-reference" href="_images/DAC6_TB.png"><img alt="_images/DAC6_TB.png" src="_images/DAC6_TB.png" /></a>
</div>
</li>
<li><p class="first">より洗練されたモデルにおいては、バイアス入力の要求仕様、非線形性 and/or デジアナ変換時のランダムオフセット等の特性も含めるべきである。</p>
</li>
<li><p class="first">これにはより包括的なテストベンチが必要で、特定の入力信号を生成、出力波形を取得、要求された特性の計算を行うテストベンチが必要である</p>
</li>
<li><p class="first">Verilog-AMSは、これらを自然に記述することができる</p>
</li>
<li><p class="first">推奨される方法は、特定のテストと出力がスペックを満足しているかのレポートを、taskで定義することである</p>
</li>
<li><p class="first">例えば、デジタル入力に特定の値を入れ、出力値が正しいかどうかをチェックようにtaskを定義する</p>
</li>
<li><p class="first">taskの動作</p>
<ol class="arabic simple">
<li>Dinに特定の値を入れる。</li>
<li>出力が反応するまでの特定時間待つ。</li>
<li>出力期待値を計算する。</li>
<li>実際の出力と期待される出力を比較し、スペック外であればメッセージを出力する。</li>
<li>テストのpassとfailの数をカウントする。</li>
</ol>
</li>
<li><p class="first">以下、上記動作の記述を示す。各入力値において出力が期待値の1%以内かをチェックする。</p>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">integer</span> <span class="n">CountErr</span><span class="o">=</span><span class="mh">0</span><span class="p">,</span><span class="n">CountOK</span><span class="o">=</span><span class="mh">0</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>   <span class="c1">// variables to keep running count of tests</span>
<span class="k">task</span> <span class="n">D2Acheck</span><span class="p">;</span>                    <span class="c1">// task to check for valid response</span>
 <span class="k">input</span> <span class="kt">real</span> <span class="n">Dval</span><span class="p">;</span>
 <span class="kt">real</span> <span class="n">Anom</span><span class="p">,</span><span class="n">PctErr</span><span class="p">;</span>
 <span class="k">begin</span>
  <span class="n">Din</span> <span class="o">=</span> <span class="n">Dval</span><span class="p">;</span>
  <span class="p">#</span><span class="mh">50</span> <span class="n">Anom</span> <span class="o">=</span> <span class="no">V</span><span class="p">(</span><span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span><span class="o">*</span><span class="n">Din</span><span class="o">/</span><span class="mh">63</span><span class="p">;</span>
  <span class="n">PctErr</span> <span class="o">=</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="n">Aout</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span><span class="o">-</span><span class="n">Anom</span><span class="p">)</span><span class="o">/</span><span class="no">V</span><span class="p">(</span><span class="n">Vdd</span><span class="p">,</span><span class="n">Vss</span><span class="p">)</span><span class="o">*</span><span class="mh">100</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">PctErr</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="p">)</span> <span class="k">begin</span>
   <span class="nb">$display</span><span class="p">(</span>
   <span class="s">&quot;*SpecErr: Din=%b Anom=%5.3f Aout=%5.3f Out of spec by %.1f%% at T=%.1fns&quot;</span><span class="p">,</span>
          <span class="n">Din</span><span class="p">,</span>  <span class="n">Anom</span><span class="p">,</span>   <span class="no">V</span><span class="p">(</span><span class="n">Aout</span><span class="p">,</span><span class="n">Vss</span><span class="p">),</span>    <span class="n">PctErr</span><span class="p">,</span> <span class="nb">$realtime</span><span class="p">);</span>
   <span class="n">CountErr</span><span class="o">=</span><span class="n">CountErr</span><span class="o">+</span><span class="mh">1</span><span class="p">;</span>
  <span class="k">end</span>
  <span class="k">else</span> <span class="n">CountOK</span><span class="o">=</span><span class="n">CountOK</span><span class="o">+</span><span class="mh">1</span><span class="p">;</span>
 <span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">taskを利用して、特定コードのチェック、適切な動作検証のためのテスト手順を記述することができる。</p>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">initial</span> <span class="k">begin</span>             <span class="c1">// This is the sequential test procedure</span>
 <span class="n">Vsup</span><span class="o">=</span><span class="mh">3</span><span class="p">;</span> <span class="n">Vgnd</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>          <span class="c1">// Initial 3 volt supply and ground voltage</span>
 <span class="n">Tr</span><span class="o">=</span><span class="mh">100</span><span class="n">n</span><span class="p">;</span>                 <span class="c1">// risetime for supply changes</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mh">64</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span> <span class="n">D2Acheck</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>      <span class="c1">// check all 64 codes</span>
 <span class="n">D2Acheck</span><span class="p">(</span><span class="mh">32</span><span class="p">);</span>            <span class="c1">// check midrange point</span>
 <span class="n">Vsup</span><span class="o">=</span><span class="mf">2.4</span><span class="p">;</span>  <span class="p">#</span><span class="mh">100</span>          <span class="c1">// ramp to new supply voltage</span>
 <span class="n">D2Acheck</span><span class="p">(</span><span class="mh">32</span><span class="p">);</span>            <span class="c1">// recheck midrange point</span>
 <span class="n">Vsup</span><span class="o">=</span><span class="mh">3</span><span class="p">;</span>  <span class="p">#</span><span class="mh">100</span>
 <span class="n">Vgnd</span><span class="o">=</span><span class="mf">0.4</span><span class="p">;</span>  <span class="p">#</span><span class="mh">100</span>          <span class="c1">// switch to different negative reference</span>
 <span class="n">D2Acheck</span><span class="p">(</span><span class="mh">32</span><span class="p">);</span>            <span class="c1">// recheck midrange point</span>
 <span class="p">#</span><span class="mh">100</span> <span class="n">Vgnd</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
 <span class="p">#</span><span class="mh">100</span> <span class="k">if</span> <span class="p">(</span><span class="n">CountErr</span><span class="o">==</span><span class="mh">0</span><span class="p">)</span> <span class="nb">$display</span><span class="p">(</span><span class="s">&quot;*SpecPASS - DAC8: all %d tests passed&quot;</span><span class="p">,</span><span class="n">CountOK</span><span class="p">);</span>
   <span class="k">else</span> <span class="nb">$display</span><span class="p">(</span><span class="s">&quot;*SpecFAIL - DAC8: %d failures out of %d tests&quot;</span><span class="p">,</span>
                <span class="n">CountErr</span><span class="p">,</span> <span class="n">CountErr</span><span class="o">+</span><span class="n">CountOK</span><span class="p">);</span>
 <span class="p">#</span><span class="mh">1</span> <span class="nb">$stop</span><span class="p">;</span>                <span class="c1">// done with testing</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<a class="reference internal image-reference" href="_images/DAC6_TB2.png"><img alt="_images/DAC6_TB2.png" src="_images/DAC6_TB2.png" /></a>
</div>
</li>
<li><p class="first">このようなテストは仕様変更による繰り返しテストを行うときに特に役立つ</p>
</li>
<li><p class="first">テストベンチはモデルが定義された仕様を満足するかテストされているかどうかをレポートする。</p>
</li>
<li><p class="first">同じテストベンチをトランジスタレベルのテストでも使用でき、各viewが定義された精度内で仕様にマッチするか検証できる。</p>
</li>
<li><p class="first">検証手順のコード開発に多くの時間がかかるとしても、このアプローチは検証プロセスの自動化にを助けることができる。</p>
</li>
<li><p class="first">アナログとMixed-Signalの検証プロセスにおいて、一度このような手順を標準的に実行すれば、すぐにシステムレベル検証手順の用途に適用することができる。</p>
</li>
</ul>
</div>
<div class="section" id="id13">
<h3>Real Number Modeling<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first">RNMでは、アナログの電圧値は、時間変動の実数シーケンスとして表現される。実際には、これはアナログシミュレータが行っていることと同じである。アナログシミュレータとの違いは、モデルが方程式として定義されているかどうか、という点である。回路シミュレータは、回路トポロジからキルヒホッフの法則に基づき、方程式を作り、その方程式を各タイムステップで全体を満たすように解き、電圧・電流を求める。それに対して、離散システムでは、電圧対電流の関係式はなく、また、キルヒホッフの法則も、方程式を同時に解かないといけない、という制約もない。電流の効果やフィードバック機構の影響を無視(これにより、ドライバと負荷の間の相互関係はなくなる)した入力から、出力を直接計算するだけである。</p>
</li>
<li><p class="first">これは、抽象的すぎる計算モデルであり、トランジスタレベルのシミュレーションとはかけ離れたものである。しかしながら、トランジスタレベルよりも遥かに高い抽象度でシステムを記述することで、システム全体の関係を記述することができる。入力が変動した場合、信号は回路ブロック(例えば、比較回路、スケール回路、変換回路、フィルタ、遅延回路、スリュー回路など)により処理され、出力信号が生成される。このようなRNMのコンセプトは、システムの検証だけではなく、探索にも使用できる。トランジスタレベルでサブシステムを検証し、その後、そのブロックのビヘイビアモデルを使用して、システムを高抽象度で検証するのは、もはや常識である。また、AMSモデリング技術ではなく、実数技術を用いて、ビヘイビアモデルを作成することは、前述の自然な拡張であり、システムレベルの検証において、スループットを高めることができる。</p>
</li>
<li><p class="first">実数モデルのコンセプトは、簡単なものである。もし、入力/出力の関係が伝達関係にあるならば、入力が変化した時に、出力が更新されるという関係を数式で記述すればよい。固定電圧(バイアス、電源など)の場合も単純である。電源電圧や、バイアス電流、電圧入力は、実数値としてモデル化される。シミュレータは、それらが適切な許容範囲であるか、出力が適切なバイアスで制御されているかどうかチェックする。これらの動作は、PGAの例で既に記述したとおりである。</p>
</li>
<li><p class="first">実数モデルで、時間変動の波形を表現するためには、もう少しやるべきことがある。アナログ記述言語では、立ち上がり時間を指定したり、スリュー、積分、微分などのアナログフィルタはビルトインとして用意されているのに対して、実数モデリングでは、このような関数は自動的に使用することができない。代わりに、離散システムでシステムを記述する必要がある。大抵の効果は数行で書くことができるが、いささか経験が必要となる。もし、実数モデルを始めるならば、最初にこのような関数をライブラリ化しておくことをお勧めする。これによって、経験の無さを補うことができるだけでなく、効果的に利用することができる。一度このような伝達関数の変換を経験すると、今後、アナログ特性を離散モデルに変換するのに役に立つであろう。</p>
</li>
<li><p class="first">アナログシステムでは、積分動作はよく使用される。離散システムでは、入力は時系列のデータとして与えられ、出力は入力の過去の値と現在の値から、台形積分法を用いて計算される。</p>
<blockquote>
<div><p>OUT_new = OUT_old + (T_new - T_old)*(IN_new + IN_old)/2</p>
</div></blockquote>
<p>つまり、入力が変化した場合、新しい出力(OUT_new)は、T_new, IN_newから求めることができる。</p>
</li>
</ul>
</div></blockquote>
<div class="section" id="verilog-ams-wreal-low-pass-filter">
<h4>Verilog-AMS/wreal Low-pass Filter<a class="headerlink" href="#verilog-ams-wreal-low-pass-filter" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">ローパスフィルタは、離散システムの時間応答の定式化に非常に役に立つ例である。アナログドメインでは、フィルタ特性は、ポールとゼロ点を持つ多項式として記述される(H(s)=N(s)/D(s))。このラプラス形式の表現は、周波数領域ではよく機能し、また、RLC回路に簡単にマッピングできる。しかし、イベントドリブンな離散システムでは、この形式は抽象的過ぎる。離散システムでは、フィルタ特性はZ領域で記述される。Z領域では、出力は、入力の項と、遅延された入力の項で表現される。</p>
</li>
<li><p class="first">H(s)からH(z)に変換する方法には、標準的なものがある。</p>
</li>
<li><p class="first">例として、1次のローパスフィルタを考える。周波数領域では、以下の伝達関数で与えられる。</p>
<blockquote>
<div><dl class="docutils">
<dt>H(s) = OUT / IN = 1 / (1 + s/Wp)</dt>
<dd><p class="first last">Wp: コーナー周波数[rad/sec]</p>
</dd>
</dl>
</div></blockquote>
<p>H(s)からH(z)の変換には、以下の双一次変換(Bilinear Transform)を用いて、変換することができる。</p>
<blockquote>
<div><dl class="docutils">
<dt>s = (2/Ts) * (1-z^(-1)) / (1+z^(-1))</dt>
<dd><p class="first last">Ts: サンプリングレート, z^(-1): 単に遅延素子</p>
</dd>
</dl>
</div></blockquote>
<p>これをs領域の伝達関数に適用すると、</p>
<blockquote>
<div><p>H(z) = 1 / (a + (2/WpTs)(1-z^(-1))/(1+z^(-1)))</p>
</div></blockquote>
<p>(1+z^(-1))を分母・分子にかけると</p>
<blockquote>
<div><p>H(z) = (1 + z^(-1)) / (1 + 2/WpTs + (1 - 2/WpTs)z^(-1)) = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))</p>
</div></blockquote>
<p>ここで、</p>
<blockquote>
<div><p>n0 = 1, n1 = 1, d0 = 1 + 2/WpTs, d1 = 1 - 2WpTs</p>
</div></blockquote>
<p>である。次に、結果の差分式を計算する式をコードに落とし込む。</p>
<blockquote>
<div><p>H(z) = OUT / IN = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))</p>
</div></blockquote>
<p>INとOUTの関係を導くために、式を変形する。</p>
<blockquote>
<div><p>OUT * (d0 + d1*z^(-1)) = IN * (n0 + n1*z^(-1))</p>
</div></blockquote>
<p>OUTについて解く(z^(-1)は、遅延単位素子であることを思い出す)。</p>
<blockquote>
<div><p>OUT = (n0*IN + n1*z^(-1)*IN - d1*z^(-1)*OUT) / d0</p>
</div></blockquote>
<p>最後に、z^(-1)を過去の値に置き換えることで、望ましい式を得ることができる。</p>
<blockquote>
<div><p>OUT_new = (IN_new * n0 + IN_old * n1 - OUT_old * d1) / d0</p>
</div></blockquote>
<p>ローパスフィルタのVerilog-AMS/wrealのコードを以下に示す。</p>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//`include &quot;constants.vams&quot;</span>
<span class="no">`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ps</span>

<span class="cp">`define M_TWO_PI (2*3.14159)</span>

<span class="k">module</span> <span class="n">LPF1s</span><span class="p">(</span><span class="no">OUT</span><span class="p">,</span> <span class="no">IN</span><span class="p">);</span>
  <span class="k">output</span> <span class="no">OUT</span><span class="p">;</span>
  <span class="k">input</span> <span class="no">IN</span><span class="p">;</span>
  <span class="n">wreal</span> <span class="no">OUT</span><span class="p">,</span> <span class="no">IN</span><span class="p">;</span>

  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Fp</span> <span class="o">=</span> <span class="mf">10e+6</span><span class="p">;</span>      <span class="c1">// corner frequency [Hz]</span>
  <span class="k">parameter</span> <span class="kt">real</span> <span class="n">Ts</span> <span class="o">=</span> <span class="mf">10e-9</span><span class="p">;</span>      <span class="c1">// sample rate [sec]</span>
  <span class="kt">real</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">ts_ns</span><span class="p">;</span>

  <span class="k">initial</span> <span class="k">begin</span>
    <span class="n">ts_ns</span> <span class="o">=</span> <span class="n">Ts</span><span class="o">/</span><span class="mf">1e-9</span><span class="p">;</span>      <span class="c1">// sample rate converted to nanoseconds</span>
    <span class="n">d0</span> <span class="o">=</span> <span class="mh">1</span> <span class="o">+</span> <span class="mh">2</span><span class="o">/</span><span class="p">(</span><span class="no">`M_TWO_PI</span> <span class="o">*</span> <span class="n">Fp</span> <span class="o">*</span> <span class="n">Ts</span><span class="p">);</span>   <span class="c1">// denominator coefficients</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="mh">1</span> <span class="o">-</span> <span class="mh">2</span><span class="o">/</span><span class="p">(</span><span class="no">`M_TWO_PI</span> <span class="o">*</span> <span class="n">Fp</span> <span class="o">*</span> <span class="n">Ts</span><span class="p">);</span>
  <span class="k">end</span>

  <span class="kt">real</span> <span class="n">INold</span><span class="p">,</span> <span class="n">OUTval</span><span class="p">;</span>   <span class="c1">// saved value of input &amp; output</span>

  <span class="k">always</span> <span class="p">#(</span><span class="n">ts_ns</span><span class="p">)</span> <span class="k">begin</span>      <span class="c1">// sample input every Ts seconds</span>
    <span class="n">OUTval</span> <span class="o">=</span> <span class="p">(</span><span class="no">IN</span> <span class="o">+</span> <span class="n">INold</span> <span class="o">-</span> <span class="n">OUTval</span> <span class="o">*</span> <span class="n">d1</span><span class="p">)</span> <span class="o">/</span> <span class="n">d0</span><span class="p">;</span>   <span class="c1">// compute output from input &amp; state</span>
    <span class="n">INold</span> <span class="o">=</span> <span class="no">IN</span><span class="p">;</span>         <span class="c1">// saved old value for use next step</span>
  <span class="k">end</span>

  <span class="k">assign</span> <span class="no">OUT</span> <span class="o">=</span> <span class="n">OUTval</span><span class="p">;</span>  <span class="c1">// pass value to output pin</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">上記のモデルが正しく動いているかは、ステップ入力を与えた時に出力が適切な時定数で動いているかどうかで検証することができる。3つのローパスフィルタ(それぞれ、異なるコーナー周波数を設定)を配置し、ステップ入力を与えるテストベンチと波形を以下に示す。</p>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="n">LPF1s_TB</span><span class="p">();</span>      <span class="c1">// testbench to check response of low-pass filters</span>
  <span class="n">wreal</span> <span class="no">OUT1</span><span class="p">,</span> <span class="no">OUT2</span><span class="p">,</span> <span class="no">OUT3</span><span class="p">,</span> <span class="no">IN</span><span class="p">;</span>

  <span class="n">LPF1s</span> <span class="p">#(.</span><span class="n">Fp</span><span class="p">(</span><span class="mf">10e+6</span><span class="p">),</span>  <span class="p">.</span><span class="n">Ts</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">))</span>  <span class="no">LP1</span><span class="p">(</span><span class="no">OUT1</span><span class="p">,</span> <span class="no">IN</span><span class="p">);</span>   <span class="c1">// Tau = 1/2πFp = 16ns</span>
  <span class="n">LPF1s</span> <span class="p">#(.</span><span class="n">Fp</span><span class="p">(</span><span class="mf">30e+6</span><span class="p">),</span>  <span class="p">.</span><span class="n">Ts</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">))</span>  <span class="no">LP2</span><span class="p">(</span><span class="no">OUT2</span><span class="p">,</span> <span class="no">IN</span><span class="p">);</span>   <span class="c1">// Tau = 5.3ns</span>
  <span class="n">LPF1s</span> <span class="p">#(.</span><span class="n">Fp</span><span class="p">(</span><span class="mf">100e+6</span><span class="p">),</span> <span class="p">.</span><span class="n">Ts</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">))</span> <span class="no">LP3</span><span class="p">(</span><span class="no">OUT3</span><span class="p">,</span> <span class="no">IN</span><span class="p">);</span>   <span class="c1">// Tau = 1.6ns</span>

  <span class="kt">real</span> <span class="n">Vin</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>        <span class="c1">// initialize input to 0</span>
  <span class="k">always</span> <span class="p">#</span><span class="mh">20</span> <span class="n">Vin</span> <span class="o">=</span> <span class="mh">1</span> <span class="o">-</span> <span class="n">Vin</span><span class="p">;</span>     <span class="c1">// alternate between 0 and 1 every 20ns</span>
  <span class="k">assign</span> <span class="no">IN</span> <span class="o">=</span> <span class="n">Vin</span><span class="p">;</span>     <span class="c1">// drive input pin with Vin value</span>
  <span class="k">initial</span> <span class="p">#</span><span class="mh">120</span> <span class="nb">$stop</span><span class="p">;</span>  <span class="c1">// stop after several cycles</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<a class="reference internal image-reference" href="_images/LPF_WREAL.png"><img alt="_images/LPF_WREAL.png" src="_images/LPF_WREAL.png" /></a>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="modeling-best-practices-considerations">
<h2>Modeling Best Practices Considerations<a class="headerlink" href="#modeling-best-practices-considerations" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">特性を上手く定義してコーディングしたモデルは、リーズナブルに保証する事が出来る。</div>
<div class="line">ただし、そのようにモデリングするには、以下の３つを実施する必要がある。</div>
</div>
<ol class="arabic">
<li><div class="first line-block">
<div class="line">モデルに何を表現させるか決定する。</div>
<div class="line">通常、モデルを作成する時間よりも、ブロックのモデルとして何を書くべきかを明らかに定義する時間を長く取る。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">必要なオペレーションが行われるために正しくコードを記載する。</div>
<div class="line">さまざまなモデル作成方法を検討し、モデルに何を描く事が出来るのかを余裕を持って考慮しなければならない。</div>
<div class="line">モデル作成者のコード生成に影響し、そしてシミュレーションの効果にも影響する。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">モデルが正しく動く事を証明する。</div>
<div class="line">すべてのテストケースを試験する事が出来るテストベンチを書く事は、モデル開発とは別です。</div>
<div class="line">それを作成するためには非常に長い時間がかかる。テストは文字通り、モデル開発の後ろ半分になります。</div>
</div>
</li>
</ol>
<div class="line-block">
<div class="line">モデル開発でほとんどの時間として取られているのは、コーディングではないと認識しなければならない。</div>
<div class="line">しかし、良いコーディングの練習は、モデルの効果的な使用方法に重要です。</div>
<div class="line">各種のモデリング記述はモデル開発のプロセスにおいて助けとなるでしょう。</div>
</div>
<div class="section" id="analog-best-practices">
<h3>Analog Best Practices<a class="headerlink" href="#analog-best-practices" title="Permalink to this headline">¶</a></h3>
<ul>
<li><div class="first line-block">
<div class="line">SPICEのようなアナログシミュレータは、全(非線形)システムの全ての方程式を解くためにNewton-Raphson[1]型の反復技術を使います。</div>
<div class="line">ビヘイビアモデル、トランジスタモデル、接点からなるキルヒホッフの法則から、各タイムポイントにおけるネットワークを解きます。</div>
<div class="line">ビヘイビアモデルは他のシステム内臓モデルに拡張される。</div>
<div class="line">良い結果を提供するシミュレーターの能力に影響を与え、解の収束性を上げるのは、モデルの品質です。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">良いモデルを開発するための鍵は、シミュレーターがそのモデルをどのように扱うのかを理解する事です。</div>
<div class="line">ほとんどのアナログシステムは、その回路にフィードバックを持っています。</div>
<div class="line">アンプは、その特性を制御するためにクローズループを使っています。</div>
<div class="line">トランジスタレベルのデザインでは、時々、正しい動作を作るトランジスタの間の複雑なフィードバック関係が使われています。</div>
<div class="line">そして、単純な抵抗ドライバーもフィードバックシステムであり、電流-電圧方程式を入力信号と出力電圧を比較して解かなければならない。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">A direct solution method[2]は、もしリニアシステムだけが定義されている場合に、直接、同じポイントの電圧と電流をイタレーションなしに計算する方法です。</div>
<div class="line">しかし、実際のシステムでは完璧なリニア特性はありません。</div>
<div class="line">全てのものには、オペレーションに境界があり、しばしば電源リミット、又はトランジスタによって発生するパフォーマンスリミットによって引き起こされます。</div>
<div class="line">システム内で、本質的に非線形トポロジーの変化をON/OFFする事が一般的です。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">一般的なアナログシミュレーションは、各小ステップで線形性を超えると、十分に短いタイムステップに時間軸をします。</div>
<div class="line">これは小さなタイムステップを超えて起こるべき現象を説明する連立方程式の解を計算可能にします。</div>
<div class="line">シミュレーターが各ステップでどの程度の誤差になるかによって、かなりの量の推測[1]が入ります。</div>
<div class="line">問題なく解を得られるタイムステップの大きさを、そして新しいタイムポイントでキルヒホッフの電圧-電流法則を解くために十分な解が得られるイタレーション回数と収束を決定します。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">非線形システムの場合、このイタレーション行程は保証されない。各イタレーションは非線形の関係を再評価するたために要求される新しい解を推測します。</div>
<div class="line">もし、解が確かなイタレーション回数の内に十分な精度の値に収束しなかったら、シミュレーターは非線型のためにはステップサイズが大きすぎると想定し、そのポイントの計算をあきらめます。</div>
<div class="line">そして、それは、前のタイムポイントよりも小さなタイムステップで再計算します。</div>
</div>
</li>
</ul>
</div>
<div class="section" id="cause-of-transient-solution-problems">
<h3>Cause of Transient Solution Problems<a class="headerlink" href="#cause-of-transient-solution-problems" title="Permalink to this headline">¶</a></h3>
<p>ここに、収束性の問題が発生する原因となる事をリストアップした。</p>
<ul>
<li><div class="first line-block">
<div class="line">解をもたない方程式のシステムを立てられる事</div>
<div class="line">- 方程式を解くために虚数値が要求されるフィードバック</div>
<div class="line">- 回路のオープンノードに理想電流が流れ込むトポロジー</div>
<div class="line">これらのシチュエーションは、現実には起こりえない。しかし、ビヘイビアコードでは完全に理想的なデバイス又は方程式を記述する事によって簡単に定義する事が出来る。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">有効な解の範囲を持つ方程式のシステムを立てられる事</div>
<div class="line">- 変換特性に&#8221;デッドゾーン&#8221;があるフィードバック</div>
<div class="line">- どこからも接続されていないノードを定義したスイッチング</div>
<div class="line">ビヘイビアを定義するための方程式が存在しないこれらのシチュエーションの結果は、幾つかの値は正しいだろう。この問題は、システムが有効範囲のいかなる値も想定出来ないという事である。</div>
<div class="line">全体のシステムの方程式を解くための連立方程式において不適切な方程式がノードにあった場合、解くことが出来ない不良条件マトリックス[3]と数学上呼ばれる結果になる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">ビヘイビアモデルにおいて、コントロールの変化が発生した際に（if/else関係に基づき、又は離散値に基づき）一つの値から別の値へ不連続に変化するアナログの出力特性を定義するのは簡単である。</div>
<div class="line">この手のアナログドライバーの問題は、システムが記述された値変化に正確に対応しなければならない事です。</div>
<div class="line">もし、シミュレータが、このような離散値変化が発生した時の解にイタレーションに問題があった場合、そのオプションはとても限定的です。</div>
<div class="line">より短いタイムステップで試そうとし、しかし離散的な変化を作れなかったならば、シミュレーションは収束に失敗するか、精度を無視してより短いタイムステップでの計算を続けます。どちらにせよ解決法は無い。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">スレッショルドを超えた時に入力依存のあるゼロから、入力依存のある有効値まで変化するモデル（一般的には、部分的に線形なタイプの変換特性が定義されたモデル）は問題がある。</div>
<div class="line">もしそれらの関係が、フィードバックの変化に寄らずに入出力変換特性が使われていたなら、正しくシミュレーションできるだろう。</div>
<div class="line">しかし、もしこのタイプの依存にフィードバックが使われていたならば、ファンクションへの入力値は、ファンクションの出力に依存して定義される。</div>
<div class="line">イタレーションの問題は、シミュレータが変換関係において横切った時に起こるだろう。</div>
<div class="line">３つの現象が、問題の原因である。</div>
</div>
<ul>
<li><div class="first line-block">
<div class="line">もし、入出力依存のスロープが１セグメント内でゼロの場合、Newton-Raphson法アルゴリズムのイタレーションは、正しい解より近い入力を得るための変化を決定するために、そのセグメント内で利用できる情報を持ちません。</div>
<div class="line">そのため、解が無いと、ソルバ－に返します。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Newton-Raphsonイタレーションアルゴリズムは、入出力変換特性のスロープに基づく方程式のセットを解くための探索を試みます。</div>
<div class="line">図12は、通常のイタレーションにおけるF(x)=0の式を解くための行程を示します。</div>
<div class="line">x=P0点で始まり、f(P0)値とその点において方程式の解で推測された線形を仮定した場合のスロープを使う。</div>
<div class="line">全連続の変換特性のため、この手順が実際の解に高速に収束させるゼロクロスポイント周辺の値の幅となる。</div>
<div class="line">しかし、部分線形フォーマットで定義されたファンクションの場合、収束は単に適切なセグメント内に予測したポイントがあるかを観察するのみ。</div>
<div class="line">この場合、一般的なNewton-Raphsonイタレーションは解を生成しない。そして、幾つかの他のアプローチによって解を見つけなければならない。</div>
<div class="line">この問題が、数千の方程式を持つ中規模のシステムで発生した時、解法につまづきFailします。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">もし、シミュレータがスロープのステップ変化を変更したなら、非線形性の高いシステムの兆候として急激な変化を解釈、そして小さなタイムステップに力を入れるだろう。</div>
<div class="line">期待よりもより多くの計算点がシミュレーションに必要となる。</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="propoer-analog-expression-development">
<h3>Propoer Analog Expression Development<a class="headerlink" href="#propoer-analog-expression-development" title="Permalink to this headline">¶</a></h3>
<ul>
<li><div class="first line-block">
<div class="line">アナログシミュレーターのイタレーション問題を避けるための一つの方法は、ビヘイビアモデルの信号タイプを把握しておく事である。</div>
<div class="line">アナログreal変数、又は値は、機能のタイプとして以下の３つの内の１つのタイプを持つを持つ。</div>
</div>
<ol class="arabic">
<li><div class="first line-block">
<div class="line">Continuous</div>
<div class="line">値にステップ的な変化が無い。</div>
<div class="line">電圧や電流が自動的になるタイプで、時間変数$abstimeと$realtimeそして、このタイプの式の計算の組み合わせが可能。</div>
<div class="line">連続信号は、アナログ電圧又は、電流を制御に使う事が出来る。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Discrete</div>
<div class="line">値は、ほとんどの時間一定である。しかし、特別なタイムポイントにおいて、新しい値に変化する事が出来る。</div>
<div class="line">これらの定義は、値を選択するためにif又はcase文を使用して作る事が出来る。</div>
<div class="line">又はイベントドリブン構文&#64;(cross())又は&#64;(timer)を通して、integer変数に依存、又はAMSシステムの分散的な変数に依存して作られる。</div>
<div class="line">discrete信号は、アナログ回路の制御に使用する場合には、transitionフィルターを通すべきである。</div>
<div class="line">これは、分散値の変化が発生する時にゼロではない立ち上がり時間を挿入し、連続したフォーマットに変換する。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Mixed</div>
<div class="line">電圧又は電流のどちらかで連続的に変化する値、又は新しい値に分散的に飛ぶ。</div>
<div class="line">これらの信号は、アナログ設計における問題の共通の源である。</div>
<div class="line">それらはきれいに連続値に変換する事が出来ない。</div>
<div class="line">連続的な結果が欲しい場合、連続的に組んでいるブロックの再構築をする必要がある。</div>
<div class="line">これをするためには、それらの分散成分は分離され、連続系にはtransition filterによって変換して渡されるべきである。</div>
<div class="line">そして他の連続変数と再結合する。</div>
</div>
</li>
</ol>
</li>
<li><div class="first line-block">
<div class="line">莫大なアナログモデルの問題は、上記の推奨がなされていない事が原因で起こる。</div>
<div class="line">問題は、discrete signal(2又は3)が電圧又は電流、連続的な入力信号が想定される演算で使われている事による。</div>
<div class="line">同様に、discrete signalが予想される演算でcontinuous signals(1又は3)が使われる時も。</div>
</div>
</li>
<li><p class="first">この問題を悪化させる１つの一般的な問題は、簡単なテストベンチでアナログ信号にdiscrete制御を含むモデルのシミュレーションが通る事にある。</p>
</li>
<li><div class="first line-block">
<div class="line">これらの疑わしいテクニックが問題なく使える事で判断をなまらせ、結果としてプアなモデリングで良いと信じてしまう。</div>
<div class="line">システムが大きくなるにつれ、指数的に問題の発生する確率が増加する。</div>
<div class="line">単純なテストベンチで証明されているモデルで、結果として大きなテストベンチでシミュレータは突如として動かなくなる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><strong>アナログピンを制御する信号の定義は、連続値のみで構築されなければならない。</strong></div>
<div class="line"><strong>全てのdiscrete信号は、連続系で使用する前に必ずtransitionフィルターによる変換を通さなければならない。</strong></div>
</div>
</li>
</ul>
</div>
<div class="section" id="example-of-modeling-with-proper-continuity">
<h3>Example of Modeling with Proper Continuity<a class="headerlink" href="#example-of-modeling-with-proper-continuity" title="Permalink to this headline">¶</a></h3>
<ul>
<li><div class="first line-block">
<div class="line">モデリングに注意が必要な簡単な例はアナログのマルチプレクサです。</div>
<div class="line">デジタル入力SELを持ち、IN0かIN1を出力に接続するAMSモデルを考える場合、一般的なアプローチでは選択された入力で出力を制御するためif/else分を使用します。</div>
<div class="line">このモデルは、SELが変化しない状態が長く続き、SELが変化した時に出力が異なる出力値に急に変化する。</div>
<div class="line">このような、アナログ出力を制御するSELにおける離散変化がある場合、後の方で問題となる。</div>
</div>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="n">mux0</span><span class="p">(</span><span class="no">SEL</span><span class="p">,</span><span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">);</span>
<span class="k">input</span> <span class="no">SEL</span><span class="p">;</span>     <span class="kt">logic</span> <span class="no">SEL</span><span class="p">;</span>
<span class="k">input</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">;</span> 
<span class="k">output</span> <span class="no">OUT</span><span class="p">;</span>
<span class="n">electrical</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">;</span>

  <span class="n">analog</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="no">SEL</span><span class="p">)</span> <span class="no">V</span><span class="p">(</span><span class="no">OUT</span><span class="p">)</span><span class="o">&lt;+</span><span class="no">V</span><span class="p">(</span><span class="no">IN1</span><span class="p">);</span>			<span class="c1">// driver output with IN1 when SEL=1</span>
    <span class="k">else</span>     <span class="no">V</span><span class="p">(</span><span class="no">OUT</span><span class="p">)</span><span class="o">&lt;+</span><span class="no">V</span><span class="p">(</span><span class="no">IN0</span><span class="p">);</span>    		<span class="c1">// driver output with IN0 when SEL=0</span>
  <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><div class="first line-block">
<div class="line">これを修正するためには、SELの離散変化をランプ的な変化に変換しなければならない。</div>
<div class="line">１つのアプローチは、transition関数を使用してSELを0から1までのランプ変化の信号に変換し、ランプ値によって出力を定義する方法である。</div>
<div class="line">これは、出力電圧が２つの値の間でランプ的になっているため、前のものより良いモデルとなっている。</div>
<div class="line">しかし、これは出力に対する理想的な電圧制御であり、理想的なMUXである。</div>
</div>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="n">mux0</span><span class="p">(</span><span class="no">SEL</span><span class="p">,</span><span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">);</span>
<span class="k">input</span> <span class="no">SEL</span><span class="p">;</span>     <span class="kt">logic</span> <span class="no">SEL</span><span class="p">;</span>
<span class="k">input</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">;</span> 
<span class="k">output</span> <span class="no">OUT</span><span class="p">;</span>
<span class="n">electrical</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">1</span><span class="n">n</span><span class="p">;</span>				<span class="c1">// rise/fall time to change between states</span>
<span class="kt">real</span> <span class="no">ASEL</span><span class="p">;</span>

  <span class="n">analog</span> <span class="k">begin</span>
    <span class="no">ASEL</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="no">SEL</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>		<span class="c1">// ramp between 0 and 1</span>
    <span class="no">V</span><span class="p">(</span><span class="no">OUT</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="no">ASEL</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">IN1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mh">1</span><span class="o">-</span><span class="no">ASEL</span><span class="p">)</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">IN0</span><span class="p">);</span>	<span class="c1">// ramp one on, one off on change</span>
  <span class="k">end</span>

<span class="k">end</span> <span class="k">module</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><div class="first line-block">
<div class="line">MUXのより一般的なモデルは、スイッチ部分をモデル化したものである。</div>
<div class="line">電流が入力から出力へ流れ、出力は入力＋スイッチの&#8221;ON&#8221;抵抗のインピーダンスが見える。</div>
<div class="line">より現実的なモデルは、入力から出力へのコンダクタンスをモデル化、２つのスイッチの関係を使用して２つの枝(IN0からOUT、IN1からOUT)を定義する。</div>
<div class="line">これは、その状態が切替わる時にアナログの連続した応答を十分にモデル化したものになる。</div>
<div class="line">SELが0から1に変化した時、IN0とOUTを接続するコンダクタンスは下方向にランプ化され、同時にIN1とOUTを接続するコンダクタンスは上方向にランプ化される。</div>
</div>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="n">mux0</span><span class="p">(</span><span class="no">SEL</span><span class="p">,</span><span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">);</span>
<span class="k">input</span> <span class="no">SEL</span><span class="p">;</span>     <span class="kt">logic</span> <span class="no">SEL</span><span class="p">;</span>
<span class="k">input</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">;</span> 
<span class="k">output</span> <span class="no">OUT</span><span class="p">;</span>
<span class="n">electrical</span> <span class="no">IN0</span><span class="p">,</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">1</span><span class="n">n</span><span class="p">;</span>				<span class="c1">// rise/fall time to change between states</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Ron</span><span class="o">=</span><span class="mh">100</span><span class="p">;</span>				<span class="c1">// &quot;on&quot; resistance of the switches</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Roff</span><span class="o">=</span><span class="mh">1</span><span class="no">G</span><span class="p">;</span>				<span class="c1">// &quot;off&quot; resistance of the switches</span>

  <span class="n">analog</span> <span class="k">begin</span>
    <span class="no">I</span><span class="p">(</span><span class="no">IN0</span><span class="p">,</span><span class="no">OUT</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="no">V</span><span class="p">(</span><span class="no">IN0</span><span class="p">,</span><span class="no">OUT</span><span class="p">)</span><span class="o">*</span><span class="n">transition</span><span class="p">((</span><span class="no">SEL</span><span class="o">===</span><span class="mh">0</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="n">Ron</span> <span class="o">:</span> <span class="mh">1</span><span class="o">/</span><span class="n">Roff</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>
    <span class="no">I</span><span class="p">(</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="no">V</span><span class="p">(</span><span class="no">IN1</span><span class="p">,</span><span class="no">OUT</span><span class="p">)</span><span class="o">*</span><span class="n">transition</span><span class="p">((</span><span class="no">SEL</span><span class="o">===</span><span class="mh">1</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="n">Ron</span> <span class="o">:</span> <span class="mh">1</span><span class="o">/</span><span class="n">Roff</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>
  <span class="k">end</span>

<span class="k">end</span> <span class="k">module</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">このモデルには、さらに以下の２つの効果が追加されている。</p>
<ul>
<li><div class="first line-block">
<div class="line">SEL値は&#8217;==&#8217;ではなく&#8217;===&#8217;を使用してチェックされる。</div>
<div class="line">4-stateのロジック信号は、0,1,X,Zの値を取る。</div>
<div class="line">標準的な等価演算子(&#8216;==&#8217;)を使用する場合、入力として&#8217;==&#8217;を使用してチェックできない値の場合、等号式の結果はunknownになる。</div>
<div class="line">4-stateロジック用の符合・同一演算子(&#8216;===&#8217;)を使う事によって、等しい場合にはTrueを返し、そうでない場合は全てFalseを返す。</div>
<div class="line">そのため、入力がX又はXの場合、このモデルはどちらの入力とも接続されない事になる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">モデルに&#8221;off&#8221;の出力抵抗(Roff)を定義している。</div>
<div class="line">もし、&#8221;off&#8221;条件でコンダクタンスを0と定義した場合、出力にアナログ負荷が接続されずフローティングになる。</div>
<div class="line">電圧方程式の欠如によりシミュレーションがfailする。</div>
</div>
</li>
</ul>
</li>
<li><div class="first line-block">
<div class="line">この変換の１つの興味深い結果は、理想的なMUXの抽象的なモデルは、実際のMUXの電気構造を模倣したモデルになるという事である。</div>
<div class="line">実際のデバイスは限定された時間でスイッチがオンし、限定されたon/off抵抗を有する。</div>
<div class="line">一般的動作の自然なモデリングは、スイッチのON/OFFをモデル化するのに最も効果的な方法で、理想的なモデルは結局のところ問題を作り込むに過ぎない。</div>
</div>
<blockquote>
<div><div class="figure">
<a class="reference internal image-reference" href="_images/sim_mux0_tr.png"><img alt="_images/sim_mux0_tr.png" src="_images/sim_mux0_tr.png" /></a>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="modeling-systems-with-direct-feedback">
<h3>Modeling Systems with Direct Feedback<a class="headerlink" href="#modeling-systems-with-direct-feedback" title="Permalink to this headline">¶</a></h3>
<ul>
<li><div class="first line-block">
<div class="line">出力から入力の一つのノードに直接フィードバックされているようなシステムを定義した時、ノード電圧の値を求める為に各時間でシミュレーションは繰り返し計算を行う。</div>
<div class="line">例えば、クローズループのAMPモデルを含むシステム等。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">もし変換特性のスロープが分散的に変化する（変換特性が部分的に線形な）場合、スロープが変化するステップをまたぐところで</div>
<div class="line">重大なイタレーション問題が発生する。</div>
<div class="line">これは推定を変換特性のスロープをもとにした値にアップデートする非線形解法手順の内部動作によって引き起こされる。</div>
<div class="line">フィードバックに含まれる変換特性のスロープ（つまり、一次微分係数）を変化するステップは、値を変化するステップ（不連続値）で</div>
<div class="line">通常起こるのと同様の問題を引き起こす。</div>
<div class="line">このような不連続な変換特性は、解なし又は複数解があるという結果をシステムに返す。つまり、アルゴリズムがより近い値を推測できずに結果的にシミュレータの未収束が発生する。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">効率的なシミュレーションのためには、フィードバック内の飽和限界とすべての非線形インピーダンスタイプをダイレクトフィードバックで制御する事が</div>
<div class="line">出来るように、値とスロープが連続の変換関係で定義するべきである。そして（変換特性にゼロの傾斜を持たない）単調である事が望ましい。</div>
<div class="line">このようなケースの単純な非線形は、部分的に線形な変換特性よりも、hyperbolic tangentや、指数関数、二乗関数など入力の連続関数でモデル化される。</div>
</div>
</li>
</ul>
</div>
<div class="section" id="digital-best-practices">
<h3>Digital Best Practices<a class="headerlink" href="#digital-best-practices" title="Permalink to this headline">¶</a></h3>
<ul>
<li><div class="first line-block">
<div class="line">Verilogにおけるデジタルのモデリングについては多くの本や、Web[5]に記述があるが、これらは合成するためのコードを開発するためのもので</div>
<div class="line">ミックスドシグナルのビヘイビアモデルを作成する目的のものではない。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">AMSの章において、descreteのプログラムのゴールは機能を記述する事、そして妥当性の範囲を定義する事です。</div>
<div class="line">多くのケースで、デジタルモデルはアナログ動作を設定するための制御(discrete real)として、又はアナログ比較の状況をレポートするために定義されます。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">技術者がいくつかのdescrete動作を作るために必要なアナログモデリングを知っていると、幾つかの誤解が問題の原因になるだろう。</div>
<div class="line">アナログモデリングにおいて、すべてのタイムポイントですべての計算が行われる。</div>
<div class="line">もしこの考えがデジタルモデリングに引き継がれた場合、モジュールは、いかなる変化にも対応するように1つの大きなalways文で書かれるだろう。</div>
<div class="line">これはdescreteコードとしては効果的なアプローチではなく、実際の要求よりも多くの計算を必要とするコードになってしまう。</div>
<div class="line">descrete処理を定義する時、全信号のアップデートはごく稀な処理のため、変換特性を分解する事によって、モデルはコードの小さなセグメントだけを評価するようになり、モデルのより効果的な実行が期待できる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">もう一つの一般的な間違いは、連続に起こる依存の処理です。</div>
<div class="line">単純に入力が変化した時にいつでも出力がアップデートされる（always &#64;(vars)又は、assign文で)か、</div>
<div class="line">又は入力がサンプリングイベントが発生した時(always &#64;(&lt;event&gt;)文)にアップデートされるか、</div>
<div class="line">又は入力が一定時間で応答を変化させるように特定のタイムステップサイズで再計算させる(always #(td)文)かを決めなければならない。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">例外処理は非常に重要です。</div>
<div class="line">ブロック記述では、目的の入力が提供された場合にそのブロックが何をするかを記述するが、すべての入力が検討されなければならない。</div>
<div class="line">入力がXやYの場合や、妥当でない選択をした場合、電源電圧やバイアス値が範囲外にある場合にどういった動きをするかを決める必要がある。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">無効状態からどのようにモジュールが回復するかを定義するのも重要である。</div>
<div class="line">例えば、組み合わせ論理で、入力が無効値から有効な値に変化した場合、入力が有効になる又はリセット信号がかかるまでunkown出力が続く。</div>
<div class="line">そのようなイベントが発生したら、出力値をunkownにする、そしてシミュレーションの残りをその状態を保つモデルを作るのは簡単である。</div>
<div class="line">入力として無効な信号が入力された時に、アサーション（第4章参照）を挿入する、又はWarningメッセージを出力するのに良いやり方である。</div>
<div class="line">回復できないような壊滅的な制御コンディションがあった場合、エラーメッセージが出力されるか、assertionで何が起こっているかの詳細が示され、シミュレーションが終了するべきである。</div>
</div>
</li>
</ul>
</div>
<div class="section" id="mixed-signal-best-practices">
<h3>Mixed-signal Best Practices<a class="headerlink" href="#mixed-signal-best-practices" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>最高のモデルを作成するためにシステムの離散時間/連続時間間の相互通信は解釈される必要がある。</li>
<li>full iterationのアナログソルバと、時間通りに前進していくだけのデジタルソルバのバックステップ機能にマージされる。</li>
</ul>
<dl class="docutils">
<dt>【DC operation】</dt>
<dd><ul class="first last">
<li><p class="first">DC動作点解析は、システムのアナログ部分の静止点の計算はもちろん、デジタル部分に必須のすべての初期化とゼロ時間演算を行う。</p>
</li>
<li><div class="first line-block">
<div class="line">まずデジタルの初期化を行ってからアナログ動作点解析を行うのは標準的技法である。</div>
<div class="line">これは、アナログ動作点解析でデジタル値を利用している場合に、動作点を探すのが難しく、より多くの時間がかかるためである。</div>
</div>
</li>
<li><p class="first">以下にMixed-signalシミュレータのアナログ-デジタル間DC動作点解析の一部の典型的な例を示す。</p>
<ol class="arabic simple">
<li>すべての個別の初期化が実行される</li>
<li>すべての個別のinitialブロックが時刻0で実行される</li>
<li>すべての個別のalwaysブロックが時刻0で実行される</li>
<li>アナログシステムはすべての電圧/電流の解に適応される</li>
</ol>
</li>
<li><p class="first">もしシステムの一部にVHDL-AMSが用いられていたら、よく似てはいるが言語仕様が異なるため若干の異なる初期化プロセスが要求される。</p>
</li>
</ul>
</dd>
<dt>【Transient operation】</dt>
<dd><ul class="first last">
<li><p class="first">DC動作点をひとたび計算すると、過渡解析手順はその点から始まり、以降の計算が繰り返される：</p>
<ol class="arabic">
<li><div class="first line-block">
<div class="line">アナログソルバは、timestepサイズを線形成と正確な制約に基づいて選び、どのtimestepも制限制御される。</div>
<div class="line">T1における新たな解が実際のT0からT1=T0+ΔTのtimestepに繰り返し適応される。</div>
<div class="line">もし解に収束しないと、アナログソルバは現在よりも小さなtimestepを選ぶ。</div>
<div class="line">この過程は収束するか、timestepサイズが最小値になる(収束失敗する)まで繰り返される。</div>
</div>
</li>
<li><p class="first">デジタルソルバはT0+からT1までのすべての離散stepで連続して実行される。</p>
</li>
</ol>
</li>
<li><p class="first">離散イベントが発生しないもしくはこのtimestep内でアナログ解に影響を与えるようなデータが変更されたら、次のtimestepまで繰り返される。</p>
</li>
<li><p class="first">デジタル回路の活動水準やデジタル解、アナログtimestepサイズ次第でアナログtimestepに含まれるデジタルイベントがいくらでもある。</p>
</li>
<li><p class="first">シミュレーション環境ではアナログの結果は、最初に評価されるデジタル部分の間連続的に手に入れられ、離散コード(initial/alwaysブロック)で測定するアナログは効率的に動作する。</p>
</li>
<li><div class="first line-block">
<div class="line">もしアナログシミュレータが離散データやtimetep中にいくつかの点で変化するようなイベントにアクセスするとしたら、アナログソルバはデジタルカーネルがデータを更新するかイベントを発生するときにデジタルソルバに再同期して戻らなければならない。</div>
<div class="line">これはアナログソルバがデジタルソルバを先導するところではどこでも実装される。</div>
</div>
</li>
<li><p class="first">つまり、離散から連続へのデータ転換と関係のあるオーバヘッドが存在する。</p>
</li>
</ul>
</dd>
<dt>【Mixed-Signal constructs of limited efficiency】</dt>
<dd><ul class="first last">
<li><p class="first">アナログやMixed-Siganlシミュレーションで使用することができ、総合的なシミュレーションスピードに大きな影響を持ついくつかの構造がある。</p>
</li>
<li><div class="first line-block">
<div class="line">交差関数の標準的なアナログ値は、&#64;(above(expr))と&#64;(cross(expr,dir))である。</div>
<div class="line">過渡解析中のこれら両方の関数の演算は以下のように定義される：</div>
</div>
<ol class="arabic simple">
<li>すべてのアナログtimestepで解いている間、式がそのtimestepをこえて適当な方向でゼロと交差しているかどうかを検討</li>
<li>もしゼロと交差しているなら、挿入された波形がゼロと交差している場所の時間許容範囲と一定の電圧内に新しい点があるかどうかを検討</li>
<li>もしステップが大きすぎたら、仕様書の許容範囲を満たすような適した時間点をとるためシミュレータは反復手段をとる</li>
</ol>
</li>
<li><div class="first line-block">
<div class="line">crossやaboveイベントが起こるときはいつでも、実際に交差する閾値に十分近いステップをシミュレータが取れるようにVerilog-AMS言語は要求している。</div>
<div class="line">モデル作成側からすると、時間点が収束するのを受け入れる前に解の並行解を要求したり、実行されるはずの公平に高価な演算は理解されなければならないが、シミュレータは正しい場所へただステップしているだけのように見える。</div>
<div class="line">このため多数のcross/above命令文が含まれていると総合的なシミュレーションスピードが低下する可能性がある。</div>
</div>
</li>
<li><p class="first">減速限界のため、cross/aboveイベントを使用している間、許容範囲内の時間/電圧のわずかな値は関数で規定されなければならない。
| わずかな許容誤差範囲値を規定することで、シミュレータは信号の別点の見積もりに十分な正確さを得てステップを戻ったり、時間のかかるステップに応じることができる。
| &#64;(above(V(in), 1n, 100m)) begin ...</p>
</li>
<li><div class="first line-block">
<div class="line">完全問題の解のため、エッジの正確なタイミングは重要ではないことが多々ある。最初のアナログ時間点のイベントに取り組むにはたいていの場合、十分である。</div>
<div class="line">このような場合、単純なif()式はtimestepの強制変換なしに閾値が交差しても動作するのに向いている。</div>
<div class="line">if(V(in)&gt;0 &amp;&amp; Vlast&lt;0) begin ...</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">もしエッジの時間が正確に計測される必要があるなら、計測するためにポイントに戻ることなくゼロを横切る式の時間を与えることで返される標準関数のlast_crossing(expr,dir)がある。</div>
<div class="line">Tcross = last_crossing(V(in), 1); ...</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">もし&#64;(cross())命令文が離散コードの内部で使用されていたら、アナログ値がゼロを横切るときのデジタルイベントを作るため、閾値の大数をつかむ必要があれば同様に分解された結果と共に、同じtimestep管理がアナログシミュレーションエンジンに適応される。</div>
<div class="line">この場合、アナログ信号は離散と同様にうまくサンプリング演算を通して変換され、離散信号を扱う離散領域で計測を行う。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">サンプリング演算がいくつかの離散オーバーヘッドを加える間、アナログtimestep命令文は全く影響せず、アナログ信号にデジタルシミュレータが答える間、アナログシミュレータにフルスピードで続けることを許す。</div>
<div class="line">通常の時間ドメインサンプリングは単純な遅延ループと共に機能する</div>
<div class="line">always #(Td) Vamp = V(in);</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">別のアプローチは、電圧/時間のトレイランスを与えられたアナログ信号の変化に基づいたイベントを生み出すabsdeltaという名前の関数を使う事である：</div>
<div class="line">always &#64;(absdelta(V(in), Vdelta, Ttol, Vtol)) Vsamp = V(in);</div>
</div>
</li>
<li><p class="first">一般に、自然に選ぶよりもかなり小さなtimestepをシミュレータに強いるどんなアナログ構造でも、シミュレーションを遅くするといえる。</p>
</li>
<li><div class="first line-block">
<div class="line">たとえば、アナログ遅延関数$absdelayは、入力から出力までのアナログ遅延を定義する。</div>
<div class="line">副作用としてシミュレータに仕様遅延サイズよりも小さなtimestepを強いる(よりよいアプローチは、ただ位相遅延の少量が必要とされるだけのアナログ遅延への一次近似である一次ローパスフィルタを使用すること)。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">同様にtransition関数は入力変化に基づいた立上り遅延を持つ信号を定義する。</div>
<div class="line">小さなゼロではない遅延、もしくは小さな立上り遅延を規定することは、出力波形を正しく生成するために小さなtimestepを実行する変化を引き起こすかもしれない。</div>
<div class="line">(解はゼロを使用され、できるだけ大きな立上り遅延がtimestepに与える影響を最小化する)</div>
</div>
</li>
<li><p class="first">$bound_step関数は、より多くの解のなかのタイムポイントを強いることで、timestepのサイズの上限を実行するのに向いている。</p>
</li>
<li><p class="first">小さなtimestepはシミュレーション進度を減速させるだけでなく、将来的に多くのtimestepのための永続効果を持つ。</p>
</li>
<li><p class="first">良い数値精度を与える典型的なアナログシミュレータ演算子は、シミュレータによって小さなアナログtimestepがとられるときはいつでも各々連続して起こるtimestepが先行するtimestepの二倍以上はないということを要求する。</p>
</li>
<li><div class="first line-block">
<div class="line">もしシミュレータの典型的timestepサイズが2ns前後で、動作イベントが1psのtimestepを強いたとすると、次の2nsの結果を計算するために別の10のフルtimestep( 2ps, 4ps, 8ps, 16ps, ..., 1024psの増分で)を取らなければならない</div>
<div class="line">動作コードによって挿入されたただ一つのtimestepによってシミュレーション速度は十倍に減少する。</div>
</div>
</li>
<li><p class="first">結論としては、小さすぎるtimestepによる動作コードは大抵、小さなtimestepを強いないコードよりも遅いシミュレーションに終る。</p>
</li>
</ul>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="real-best-practice">
<h3>Real Best Practice<a class="headerlink" href="#real-best-practice" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">ブロック間を通るそれぞれの信号のためのデータ表現は、realモデルを定義するときに最も重要である。</div>
<div class="line">標準の表現は以下を含む:</div>
</div>
<ul class="simple">
<li>Voltage (ハイインピーダンス負荷と仮定する)</li>
<li>Current (低インピーダンス負荷と仮定する)</li>
<li>Effective voltage (固定発生源、負荷インピーダンスの期待に基づく)</li>
<li>Electrical (ノード接続に基づいて実行される単純ん亜インピーダンス効果を考慮に入れる信号の電圧/電流関係をマップするいくつかの方法を使う)</li>
</ul>
</li>
<li><p class="first">変化していることをどのように理解するかで決まる信号を表現するためのいくつかの方法がある：</p>
<ul class="simple">
<li>Static (値はほぼ定数で、時々新しい値になる)</li>
<li>Updating (値は大抵変化していて、波形を追う必要があるときにはいつでも更新する)</li>
<li>Sampled (値は既知の定率で変化していて、離散点間を傾斜とみなすことができる)</li>
</ul>
</li>
<li><div class="first line-block">
<div class="line">RNMのメカニズムはデジタルモデルと同等であり、違いは、データがビットやビットベクタというよりはむしろ実数の形をしているという点である。</div>
<div class="line">システムレベルのテストによってそのモデルを使うよう強いられることが直接決まるモデリングより前に、リアルモデルで必要とされる精度を決めることが重要である。</div>
</div>
</li>
<li><p class="first">どのタイプのアナログ信号フィルタリングを要求しないモデルは、入力の関数として出力を定義できる。</p>
</li>
<li><p class="first">フィルタリングが要求される場合、信号より前の特定点で毎回値が変化する場所からは固定timestep標準フォーマットを持てるように、信号経路中のいくつかの点で標準化データ形式に最も単純に変換されることがある。</p>
</li>
<li><p class="first">基本Samplerの例は以下の通り。</p>
<blockquote>
<div><div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="n">samp</span><span class="p">(</span><span class="no">OUT</span><span class="p">,</span> <span class="no">IN</span><span class="p">);</span>                  <span class="c1">// sample input at fixed rate, pass to output</span>
  <span class="k">output</span> <span class="no">OUT</span><span class="p">;</span>
  <span class="k">input</span>  <span class="no">IN</span><span class="p">;</span>
  <span class="n">wreal</span>  <span class="no">IN</span><span class="p">,</span><span class="no">OUT</span><span class="p">;</span>
  
  <span class="k">parameter</span> <span class="n">Ts</span><span class="o">=</span><span class="mh">10</span><span class="p">;</span>                     <span class="c1">// sampling interval (ns)</span>
  <span class="k">parameter</span> <span class="n">vwig</span><span class="o">=</span><span class="mh">1</span><span class="n">p</span><span class="p">;</span>                   <span class="c1">// output wiggle added when no change (V)</span>
  
  <span class="kt">real</span> <span class="n">Vout</span><span class="p">;</span>                           <span class="c1">// variable for output drive value</span>
  
  <span class="k">always</span> <span class="k">begin</span>
    <span class="n">Vout</span> <span class="o">=</span> <span class="p">(</span><span class="no">IN</span><span class="o">==</span><span class="n">Vout</span><span class="p">)</span><span class="o">?</span> <span class="no">IN</span><span class="o">+</span><span class="n">vwing</span> <span class="o">:</span> <span class="no">IN</span><span class="p">;</span>  <span class="c1">// if input is constant, output wiggles by 1pV</span>
    <span class="p">#</span><span class="n">Ts</span><span class="p">;</span>                               <span class="c1">// at each timepoint so that data stream has</span>
  <span class="k">end</span>                                  <span class="c1">// change at fixed rate</span>
  
  <span class="k">assign</span> <span class="no">OUT</span> <span class="o">=</span> <span class="n">Vout</span><span class="p">;</span>                   <span class="c1">// drive sampled signal to output</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><div class="first line-block">
<div class="line">入力が定数にとどまっているとき、出力は特に小刻みに動く形式であることに注意する。</div>
<div class="line">フィルタに元来の入力が変化しないときでさえ計算し続けることのように、この信号に基づくどのブロックもTs ns間隔のどのイベントでも値変化がみられる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">その形式に変換することで、その階層の追加の時間依存のあるすべての演算は、入力が変化するそのたびに単純なデータ駆動型依存関係によって定義することができ、出力は新しい入力と前に格納されたいくつかの状態に基づいて再計算される。</div>
<div class="line">これは、シーケンスのそれぞれのブロックを通して入力から出力へのフローを保持している。</div>
</div>
</li>
<li><p class="first">サンプリング演算のオーダは制御できないので各ブロックでの独立したサンプリングを実行する試みは、予期せぬ遅延を生む。</p>
</li>
<li><div class="first line-block">
<div class="line">不変timestep要件を実行しないフィルタリングは可能であるが、すべての可能性のあるケースを処理するためのオーバーヘッドが各ブロックのand/or複雑性で要求される。</div>
<div class="line">たとえ入力が一定になったとしてもフィルタの出力は変化し続けなければならないためである。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">他の一般的な再サンプリングアルゴリズムは、ダウンサンプリング(すべてのNth入力点から出力へと移動するだけのサンプルレートの低下)や、平均値に基づく再サンプリング(それぞれのサンプルサイクル時間を超えて入力信号を計算する)を含む。</div>
<div class="line">留意すべきは、サンプリング周波数の妥当な比次第で(平均値に基づく再サンプリングは)DCからの入力信号の周波数領域エネルギー含量を保持することができるということである。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">更新時の入出力信号間のランダムオフセットを知らないと、周波数かジッタノイズがすべてのほかの形式に加えられる。</div>
<div class="line">これにより、(パルス幅変調(PWM)入力信号のような)入力信号の正確なDCレベルを維持する必要があるなら、常に平均値に基づく方法を用いるべきである。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">Ch.3 AMS Behavioral Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modeling-classifications">Modeling classifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-development">Model Development</a></li>
<li class="toctree-l3"><a class="reference internal" href="#design-topological-considerations">Design Topological Considerations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-modeling">Types of Modeling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#discrete-digital-modeling">Discrete Digital Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#continuous-analog-modeling">Continuous Analog Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-signal-modeling">Mixed-Signal Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#real-number-modeling">Real Number Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#combined-approaches">Combined Approaches</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basic-moeling-formats">Basic Moeling Formats</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-operational-description">Model Operational Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ams-programmable-gain-amplifier-model">AMS Programmable-Gain Amplifier Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analog-pga-model">Analog PGA Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#real-pga-model">Real PGA Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#digital-pga-model">Digital PGA Model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additional-model-coding-examples">Additional Model Coding Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#digital-verilog-d-type-flip-flop">Digital: Verilog D-type Flip Flop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analog-verlog-a-operational-amplifier">Analog: Verlog-A Operational Amplifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-signal-verilog-ams-digital-to-analog-converter">Mixed-signal: Verilog-AMS Digital to Analog Converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">Real Number Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modeling-best-practices-considerations">Modeling Best Practices Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#analog-best-practices">Analog Best Practices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cause-of-transient-solution-problems">Cause of Transient Solution Problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#propoer-analog-expression-development">Propoer Analog Expression Development</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-of-modeling-with-proper-continuity">Example of Modeling with Proper Continuity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeling-systems-with-direct-feedback">Modeling Systems with Direct Feedback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#digital-best-practices">Digital Best Practices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-signal-best-practices">Mixed-signal Best Practices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#real-best-practice">Real Best Practice</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="index.html" title="Welcome to Mixed-Signal Methodology Guide’s documentation!"
             >previous</a> |
          <a href="genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="_sources/Ch3_AMS_Behavioral_Modeling.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, Team Mixed-Signal Design Automation.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>