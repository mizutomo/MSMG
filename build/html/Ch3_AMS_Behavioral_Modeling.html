<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ch.3 AMS Behavioral Modeling &mdash; Mixed-Signal Methodology Guide 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Mixed-Signal Methodology Guide 1.0 documentation" href="index.html" />
    <link rel="prev" title="Welcome to Mixed-Signal Methodology Guide’s documentation!" href="index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="index.html">Mixed-Signal Methodology Guide 1.0 documentation</a></div>
        <div class="rel">
          <a href="index.html" title="Welcome to Mixed-Signal Methodology Guide’s documentation!"
             accesskey="P">previous</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch-3-ams-behavioral-modeling">
<h1>Ch.3 AMS Behavioral Modeling<a class="headerlink" href="#ch-3-ams-behavioral-modeling" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Analog設計者は、これまでボトムアップ手法により設計を行なってきた。</li>
<li>複数のサブシステムを含んだシミュレーションを行うとき、Trレベルでは時間がかかるため、一部ブロック(特性として見る必要のないブロック)をビヘイビアモデルに置き換えるなど、シミュレーションの高速化のためだけに機能モデルを使用してきた。</li>
<li>このようなボトムアップアプローチは、対処療法的であり、プロジェクトの銀の弾丸ではない。</li>
<li>システム設計段階から、モデルによりスペックの検証を行うトップダウン設計に移行する必要がある。</li>
<li>トップダウン・アプローチを取ることで、Executable Spec(検証可能な仕様書)となる。</li>
</ul>
</div>
<div class="section" id="modeling-classifications">
<h2>Modeling classifications<a class="headerlink" href="#modeling-classifications" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>アナログの場合、決まった抽象度というものがない。また、デジタルと異なり、モデル開発をサポートするようなツールもほとんどないため、モデル作成にかかる時間が千差万別となる。</li>
<li>シミュレーション時間も、抽象度によって、大きく異る。</li>
<li>効率的なシミュレーションを行うためには、要求に応じた適切な抽象度・複雑度のモデルを用意する必要がある。</li>
<li>モデリングする際には、以下のことを考慮する必要がある。<ul>
<li>対象としているシミュレータがAnalog/Digital/Mixed-Signalを扱えるかどうか。</li>
<li>適切な階層(抽象)構造となっているか。</li>
<li>モデルにどこまでの特性を組み込むか。1次の線形特性か、非線形特性か。</li>
</ul>
</li>
<li>モデル化において重要なことは、モデルの使用目的を把握すること。</li>
<li>モデルの使用目的が把握できていないと、無駄に抽象度の低いモデルを作ったりしてしまう。</li>
</ul>
<div class="section" id="model-development">
<h3>Model Development<a class="headerlink" href="#model-development" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>モデルの複雑さは、どのレベルであっても要素の数に依存する。<ul>
<li>もし、ブロックが巨大なピン数を持っていた場合、リーズナブルなレベルまでブレークダウンさせる。</li>
<li>ただし、これ以上機能として分割できないようなレベルにまで落とし込むのは、機能モデルとしては適切ではない。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="design-topological-considerations">
<h3>Design Topological Considerations<a class="headerlink" href="#design-topological-considerations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>サブシステムへの分割の仕方は非常に重要である。</li>
<li>時には、常識が誤った方向に導くことがある。</li>
<li>通常、デジタル回路によって制御されるアナログ回路があった場合、2つのブロックに分けられがちである。</li>
<li>上記のように分けてしまうと、アナデジ間の制御信号の抽象度が非常に低くなるだけでなく、2つのモジュールがセットでないと、検証ができなくなる。</li>
<li>モジュールを一つにして、ブロック(always?)で分割するのがよい。</li>
</ul>
</div>
</div>
<div class="section" id="types-of-modeling">
<h2>Types of Modeling<a class="headerlink" href="#types-of-modeling" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>一般的に、大規模システムの検証に用いられる抽象度のレベルとしては、下記のものがあり、用途・目的に応じて、適切な使い分けが必要。<ul>
<li>Device based design(Spectre, SPICE): 回路図から生成されたネットリスト、もしくは、Pure SPICEで解釈可能なマクロモデルで記述されたネットリスト。</li>
<li>Analog modeling(Verilog-A): 電流/電圧の関係式を記述したモデル。アナログソルバ(SPICE)で解かれる。</li>
<li>Mixed-signal modeling(Verilog-AMS, VHDL-AMS): アナログ動作とデジタル動作が同時に記述可能なレベル。</li>
<li>Discrete real number modeling(Verilog-AMS, VHDL, SystemVerilog): 電気的な動作を実数の信号レベルに置き換えたモデル。インピーダンス効果(電流・電圧の関係式)は無視され、デジタルソルバで解かれる。</li>
<li>Logic modeling(Verilog, VHDL, SystemVerilog): 0,1,X,Zでモデリング。</li>
</ul>
</li>
</ul>
<div class="section" id="discrete-digital-modeling">
<h3>Discrete Digital Modeling<a class="headerlink" href="#discrete-digital-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>デジタルの入出力関係だけが記述されたモデル。デジタルソルバで解析。アナログ要素は含まない。</li>
<li>Verilog, VHDL, SystemVerilogで記述が可能。</li>
<li>アナログIPでもデジタルの入出力のみに着眼して、本レベルで記述されることがある。</li>
</ul>
</div>
<div class="section" id="continuous-analog-modeling">
<h3>Continuous Analog Modeling<a class="headerlink" href="#continuous-analog-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>システムの電気的特性が記述。言語は、Verilog-A。</li>
<li>電圧/電流の関係が記述。また、積分・微分オペレータも使用可能。</li>
<li>Verilog-Aモデルは、非線形常微分方程式に変換。他のSPICEコンポーネントと同様の方法でSPICEソルバにより解析。</li>
<li>Trレベルと比較して、10～50倍の高速化が可能。シミュレーションのスピードアップのためには、ノード数の削減と方程式数の削減が鍵。また、弱い非線型モデルにすることで、タイムステップを伸ばすことが可能。</li>
<li>デジタルの記述は全て電気的特性に変換され、SPICEソルバで実行される。そのため、論理シミュレータで解くよりも低速になる。また、IPCを用いたCo-Simで解析することも可能であるが、解析速度はアナログシミュレータのタイプステップに律速される。</li>
</ul>
</div>
<div class="section" id="mixed-signal-modeling">
<h3>Mixed-Signal Modeling<a class="headerlink" href="#mixed-signal-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Mixed-Signalに対応したシミュレータは、1つのカーネルで離散的なデジタル回路と連続的なアナログ回路を解くことができる。</li>
<li>Verilog-AMS, VHDL-AMSが記述に用いられる。</li>
<li>AMSでは、デジタルとアナログを自然にそれぞれの抽象度で記述することができる。また、データとイベントは相互に通信可能。</li>
</ul>
</div>
<div class="section" id="real-number-modeling">
<h3>Real Number Modeling<a class="headerlink" href="#real-number-modeling" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>電気的な信号を実数としてモデル化する手法。実数信号は、電圧もしくは電流のどちらかを表現するのに使用される。</li>
<li>RNMは、Verilog-AMS, SystemVerilog, VHDLで使用可能。</li>
<li>RNMは、デジタルソルバのみで解かれるため、SPICEと比べて1000～100万倍の高速化が可能。</li>
<li>双方向的なアナログの相関関係をモデリングすることはできない。</li>
</ul>
</div>
<div class="section" id="combined-approaches">
<h3>Combined Approaches<a class="headerlink" href="#combined-approaches" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">実際には、上記の抽象度のレベルを混ぜて使用されることが多い。</p>
</li>
<li><p class="first">例えば、RFレシーバの場合、下記の抽象度が混在で使用される。</p>
<blockquote>
<div><ul class="simple">
<li>RF信号パス: RNM</li>
<li>ベースバンド, バイアス、パワー供給: Electrical</li>
<li>制御回路: ロジック</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="basic-moeling-formats">
<h2>Basic Moeling Formats<a class="headerlink" href="#basic-moeling-formats" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">この本の目的は、4タイプの記述方法における長所・短所に対する洞察力をつけること。</div>
<div class="line">各記述方法における例(Programable-Gain Amplifier)を例に述べていく。</div>
</div>
<div class="section" id="model-operational-description">
<h3>Model Operational Description<a class="headerlink" href="#model-operational-description" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>差動入力、差動出力。出力には入力をゲイン倍した電圧が出力される。</li>
<li>ゲインは、デジタルの3bitバス入力(GAIN[2:0])。</li>
<li>実際のPGAにあるその他のピン(電源、バイアス入力、出力のEnable信号)あり。</li>
<li>出力は、(VDD-VSS)/2を中心とする。</li>
<li>出力端子の出力抵抗はRoutとする。</li>
</ul>
<blockquote>
<div><table border="1" class="docutils">
<caption>List of terminals</caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">pinName</th>
<th class="head">expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>INP,INM</td>
<td>差動入力 V(INP,INM)</td>
</tr>
<tr class="row-odd"><td>OUTP,OUTN</td>
<td>差動出力 V(OUTP,OUTN)</td>
</tr>
<tr class="row-even"><td>GAIN[2:0]</td>
<td>ゲイン制御端子( <a class="reference external" href="mailto:dbmin&#37;&#52;&#48;GAIN=000">dbmin<span>&#64;</span>GAIN=000</a>, <a class="reference external" href="mailto:dbmax&#37;&#52;&#48;GAIN=111">dbmax<span>&#64;</span>GAIN=111</a> )</td>
</tr>
<tr class="row-odd"><td>VDD,VSS</td>
<td>電源</td>
</tr>
<tr class="row-even"><td>VB</td>
<td>バイアス入力</td>
</tr>
<tr class="row-odd"><td>EN</td>
<td>Enable信号( ハイインピーダンス&#64;EN=0, 通常出力&#64;EN=1 )</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="ams-programmable-gain-amplifier-model">
<h3>AMS Programmable-Gain Amplifier Model<a class="headerlink" href="#ams-programmable-gain-amplifier-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_verilogams</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="n">electrical</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">;</span>
<span class="kt">logic</span> <span class="no">EN</span><span class="p">;</span>  <span class="kt">logic</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rout</span><span class="o">=</span><span class="mh">100</span><span class="p">;</span>        <span class="c1">// output resistance for each pin</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">10</span><span class="n">n</span><span class="p">;</span>          <span class="c1">// rise/fall time for gain &amp; enable changes</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>         <span class="c1">// terms in output calculation</span>
<span class="kt">real</span> <span class="n">Gout</span><span class="p">;</span>                      <span class="c1">// output conductance (smoothly switched)</span>
<span class="k">integer</span> <span class="n">Active</span><span class="p">;</span>                 <span class="c1">// flag for active operation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>

  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="n">analog</span> <span class="k">begin</span>
<span class="c1">// Check device is active (EN high, supply &amp; bias correct):</span>
  <span class="n">Active</span> <span class="o">=</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VB</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>
  <span class="n">Av</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="o">?</span> <span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">)</span><span class="o">:</span><span class="mh">1</span><span class="n">u</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="n">Tr</span><span class="p">);</span>                  <span class="c1">// convert to V/V</span>
  <span class="n">Voctr</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">)</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                         <span class="c1">// CM output level wrt Vss</span>
  <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                        <span class="c1">// max swing of output</span>
  <span class="n">Vodif</span> <span class="o">=</span> <span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">);</span>                              <span class="c1">// gain &amp; saturation limiting</span>

<span class="c1">// Driver output pins with differential Gain*input at Rout if active,</span>
<span class="c1">// high impedance if disabled, or high attenuation on bias error:</span>
  <span class="n">Gout</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="nl">Rout:</span><span class="mh">1</span><span class="n">n</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>

  <span class="no">I</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>
  <span class="no">I</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>

<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<div class="section" id="id1">
<h4>端子の属性定義<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>deciplines.vamsを定義 (/common/appl/Cadence/mmsim/12.1_isr2/linux/tools.lnx86/spectre/etc/ahdl/deciplines.vams)</li>
<li>アナログ信号(入出力、電源、バイアス入力)は、electricalで定義。analogブロック内で使われI(),V()を使用して測定。アナログソルバで解かれる。</li>
<li>デジタル信号(GAIN,EN)は、logicで定義。デジタルブロック内で使われ、1,0,X,Zの値を持つ。デジタルソルバで解かれる。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id2">
<h4>パラメータ定義<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>定義した数値はデフォルトで、後から変更可能。</li>
<li>Trは、スペックではない。ただし、ゲインとコンダクタを変える場合にランプ的に変更するのに使用する。設定しないと、アナログソルバでtime step errorが発生します。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id3">
<h4>内部変数定義<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>realとintegerは内部変数。</li>
<li>アナログブロックでもデジタルブロックでもどちらでも使用できるが、どちらか一方でしかアクセス出来ない。</li>
<li>アナログの場合はanalogブロック内でアップデートされ、デジタルの場合はinitialかalwaysブロック内でアップデートされる。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id4">
<h4>デジタルブロック<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li>initial文: Simulationの最初で計算される。</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>DBinc(GAINの1bit辺りのゲイン増加両)を計算。</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>always文: Sim中繰り返し計算される。</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>GAINの各Bitをexclusive-ORする事で、入力信号にXが含まれるかを確認する。</li>
<li>GAIN[2:0]にXが含まれる場合はAdb=-40を設定、含まれない場合は、Adb= dbmin+DBinc*GAINでゲインを計算。</li>
<li>&#64;(GAIN)が重要。これを入れることによって、always文の解析が次のGAIN信号が変化した時に評価されるようになる。これが無かったら、解析時間は0[sec]で止まってしまい永久ループとなってしまう。</li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>アナログブロック<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">Activeフラグは、EN信号と電源電圧、バイアス電圧で決定。</div>
<div class="line">電源電圧≧2.0[V]、バイアス電圧=0.7±0.05V[V]。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Avは、Adb(ゲイン)をdBから比率に変更したもの。</div>
<div class="line">Active=1の時に計算結果、Active=0の時は0.001とする。</div>
<div class="line">Adbの急激な変化によるtime step errorを防ぐためにtransition関数で立ち上がりにTrの時間を設けている。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Voctrは、コモン電圧で電源電圧の1/2。ただし、電源・バイアスを満たさない場合には供給されないため、Active信号で制御。</div>
<div class="line">Active信号は急峻に変化するため、transition関数で立ち上がりにTrの時間を設けている。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vomaxは、出力のpeak-to-peakの最大出力のため電源電圧で定義。ただし、電源電圧が供給されていない場合には、0.001[V]とする。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vodifは、差動出力の信号成分。</div>
<div class="line">入力差動信号をゲイン倍したものになるが、AMPの動作電圧で飽和する。</div>
<div class="line">min/maxで簡単に定義する事も出来るが、実回路特性に近づけるためtanh(ハイパーボリックタンジェント)関数を使用して緩やかにリミットがかかるようにした。</div>
</div>
</li>
</ul>
<img alt="Inputとoutputの関係" src="_images/vodif.png" />
<ul>
<li><div class="first line-block">
<div class="line">Goutは、出力コンダクタンス。</div>
<div class="line">EN=1の場合は1/Routだが、EN=0の場合は1/1GΩとなる。ENの2値の切換えにはtransition関数を使用する。</div>
<div class="line">(100Ωから0.1%の変化で1MΩに到達するためEN信号による切換えは直ぐに行われる。)</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">出力端子の電流/電圧の関係を示す。コントリビューション文(&lt;+)を使用する事で、分岐点における電流と電圧の関係をノード解析によって求める。</div>
<div class="line">出力電圧だけであれば、V(OUTP,VSS)&lt;+Voctr+Vodif/2;で示せるが、コンダクタンスを式に加える事で電流成分も表す。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="analog-pga-model">
<h3>Analog PGA Model<a class="headerlink" href="#analog-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_veriloga</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span> <span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>             <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>               <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>             <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>             <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                     <span class="c1">// output enable</span>
<span class="n">electrical</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">;</span>
<span class="n">electrical</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>      <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>      <span class="c1">// gain for VCVGA=111</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Rout</span><span class="o">=</span><span class="mh">100</span><span class="p">;</span>      <span class="c1">// output resistance for each pin</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">Tr</span><span class="o">=</span><span class="mh">10</span><span class="n">n</span><span class="p">;</span>        <span class="c1">// rise/fall time for gain &amp; enable changes</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>          <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>       <span class="c1">// terms in output calculation</span>
<span class="kt">real</span> <span class="n">Gout</span><span class="p">;</span>                    <span class="c1">// output conductance (smoothly switched)</span>
<span class="k">integer</span> <span class="n">Gint</span><span class="p">;</span>                 <span class="c1">// integer value from gain bus</span>
<span class="k">integer</span> <span class="n">Active</span><span class="p">;</span>               <span class="c1">// flag for active operation</span>

<span class="c1">// Macro to convert pin coltage to logic level of 1 or 0 based on half supply:</span>
<span class="cp">`define L(pin) (V(pin,VSS)&gt;V(VDD,VSS)/2)</span>

<span class="n">analog</span> <span class="k">begin</span>
<span class="c1">// Check when enabled &amp; biased properly:</span>
  <span class="n">Active</span> <span class="o">=</span> <span class="no">`L</span><span class="p">(</span><span class="no">EN</span><span class="p">)</span><span class="o">==</span><span class="mh">1</span> <span class="o">&amp;&amp;</span> <span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">2.0</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VB</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>

<span class="c1">// Gain calculation:</span>
  <span class="p">@(</span><span class="n">initial_step</span><span class="p">)</span> <span class="n">DBinc</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>            <span class="c1">// compute per-bit increment</span>
  <span class="n">Gint</span> <span class="o">=</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">2</span><span class="p">])</span><span class="o">*</span><span class="mh">4</span> <span class="o">+</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">1</span><span class="p">])</span><span class="o">*</span><span class="mh">2</span> <span class="o">+</span> <span class="no">`L</span><span class="p">(</span><span class="no">GAIN</span><span class="p">[</span><span class="mh">0</span><span class="p">]);</span> <span class="c1">// get integer form of GAIN</span>
  <span class="n">Adb</span> <span class="o">=</span> <span class="n">dbmin</span> <span class="o">+</span> <span class="n">DBinc</span><span class="o">*</span><span class="n">Gint</span><span class="p">;</span>                           <span class="c1">// convert to gain in dB</span>
  <span class="n">Av</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="n">Active</span><span class="o">?</span> <span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">)</span><span class="o">:</span><span class="mh">1</span><span class="n">u</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>        <span class="c1">// to V/V or small if off</span>

<span class="c1">// Output signal evaluation:</span>
  <span class="n">Voctr</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span><span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">)</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                       <span class="c1">// CM output level wrt Vss</span>
  <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                      <span class="c1">// max swing of output</span>
  <span class="n">Vodif</span> <span class="o">=</span> <span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="no">V</span><span class="p">(</span><span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">);</span>                            <span class="c1">// gain &amp; saturation limiting</span>

<span class="c1">// Driver output pins with differential Gain*input at Rout if active,</span>
<span class="c1">// high impedance if disabled, or high attenuation on bias error:</span>
  <span class="n">Gout</span> <span class="o">=</span> <span class="n">transition</span><span class="p">(</span> <span class="no">`L</span><span class="p">(</span><span class="no">EN</span><span class="p">)</span><span class="o">?</span> <span class="mh">1</span><span class="o">/</span><span class="nl">Rout:</span><span class="mh">1</span><span class="n">n</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span><span class="n">Tr</span><span class="p">);</span>

  <span class="no">I</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>
  <span class="no">I</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">&lt;+</span> <span class="p">(</span><span class="no">V</span><span class="p">(</span><span class="no">OUTN</span><span class="p">,</span><span class="no">VSS</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Gout</span><span class="p">;</span>

<span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>アナログモデルは、デジタルソルバが無い場合、又は全PINがアナログ端子として定義されている場合に使用され、VerilogAで記述される。</li>
<li>verilogAを使用(VerilogAMSの一部)</li>
<li>verilogAMSで示したアナログブロックと同じ物を使用できる。ただし、デジタル部は存在しない。</li>
</ul>
</div></blockquote>
<div class="section" id="id6">
<h4>端子の属性定義<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">全ピンはelectrical又はその他の連続系で定義される。（熱、磁力、一方向or循環システム等）</div>
<div class="line">ENとGAINがelectrical宣言されるのだけVerilogAMSと違い、他は同じ。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">離散数(値)は時間で変化する電圧波形としてモデル化⇒シミュレーション速度が遅くなる。</div>
<div class="line">各デジタル信号のH→L変化にtransition波形を使用するため、多くの解析ステップが必要で通常はシミュレーションスピードが遅くなる。</div>
<div class="line">本モデルでは、GAINはまれにしか動かないので、スピード的には問題にならない。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id7">
<h4>内部変数定義<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>VerilogAMSとほぼ同じ。ただし、全てアナログブロック内で使用。</li>
<li>[追加]Gint：GAINバス入力からinteger(0～7)の値を求めるのに使用。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id8">
<h4>マクロの追加<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">デジタルノードの電圧を変換するためのマクロ(`L())を追加</p>
</li>
<li><div class="first line-block">
<div class="line">アナログブロックで、1/2電源電圧をスレッショルドとしてデジタル信号を処理、</div>
<div class="line">条件分岐はTrueで1、falseで0を返す。</div>
</div>
</li>
<li><p class="first">マクロ定義する事で、複数個所の同じ処理を簡易化（コンパイル時の影響はなし）。</p>
</li>
<li><div class="first line-block">
<div class="line">例えば、EN信号のロジックレベル判定を`L(EN)と書く事で、V(EN,VSS)&gt;V(VDD,VSS)/2の結果に置換える。</div>
<div class="line">Activeフラグも同じ。</div>
</div>
</li>
<li><p class="first">デジタルブロックで定義されていたTrue/False判定は複数個所で実行されていたためマクロ化した。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id9">
<h4>アナログブロック<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">&#64;(initial_step)は、アナログシミュレーションの初期ステップで評価を実施する(デジタルinitialと同じ)。</div>
<div class="line">DBincをアナログブロック内で初期化するのに使用。</div>
</div>
</li>
<li><p class="first">GAINバスは、electricalノードから`L()マクロを使ってロジックレベルを検知し、0～7のintegerを返す。</p>
</li>
<li><p class="first">Adb(dbゲイン)はGintを元に計算され、Av(比率ゲイン)はAMSの場合と同じ評価式で計算される。</p>
</li>
<li><p class="first">残りのコードは、EN信号のロジックレベル判定以外はAMSと同じ。</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="real-pga-model">
<h3>Real PGA Model<a class="headerlink" href="#real-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_wrealmodel</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="n">wreal</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">;</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>
<span class="kt">real</span> <span class="n">Voctr</span><span class="p">,</span><span class="n">Vomax</span><span class="p">,</span><span class="n">Vodif</span><span class="p">;</span>         <span class="c1">// terms in output calculation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>
  <span class="n">Av</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">);</span>		<span class="c1">// convert to V/V</span>
  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="c1">// Check device is active (EN high, supply &amp; bias correct):</span>
  <span class="kt">wire</span> <span class="n">Active</span> <span class="o">=</span> <span class="p">(</span><span class="no">EN</span><span class="o">===</span><span class="mh">1&#39;b1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="o">&gt;=</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">abs</span><span class="p">(</span><span class="no">VB</span><span class="o">-</span><span class="no">VSS</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">0.05</span><span class="p">;</span>
  <span class="k">always</span> <span class="k">begin</span>
    <span class="n">Voctr</span> <span class="o">=</span> <span class="n">Active</span><span class="o">*</span><span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="p">)</span><span class="o">/</span><span class="mh">2</span><span class="p">;</span>                        			<span class="c1">// CM output level wrt Vss</span>
    <span class="n">Vomax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="no">VDD</span><span class="o">-</span><span class="no">VSS</span><span class="p">),</span><span class="mf">0.001</span><span class="p">);</span>                                        <span class="c1">// max swing of output</span>
    <span class="p">@(</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="n">Active</span><span class="p">);</span>							<span class="c1">// repeat when supplies change</span>
  <span class="k">end</span>

<span class="c1">// define saturation limiting &amp; high attenuation when inactive:</span>
  <span class="k">always</span> <span class="p">@(</span><span class="o">*</span><span class="p">)</span> <span class="n">Vodiff</span> <span class="o">=</span><span class="n">Vomax</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">Av</span><span class="o">*</span><span class="p">(</span><span class="no">INP</span><span class="o">-</span><span class="no">INN</span><span class="p">)</span><span class="o">/</span><span class="n">Vomax</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Active</span><span class="o">?</span> <span class="mh">1</span><span class="o">:</span><span class="mf">1e-6</span><span class="p">);</span>

<span class="c1">// output the differential real signal if actively biased;</span>
<span class="c1">// high impedance if not enabled, otherwise X output:</span>

  <span class="k">assign</span> <span class="no">OUTP</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="n">Voctr</span><span class="o">+</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="no">`wrealZstate</span><span class="o">:</span> <span class="no">`wrealXstate</span><span class="p">;</span>
  <span class="k">assign</span> <span class="no">OUTN</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="n">Voctr</span><span class="o">-</span><span class="n">Vodif</span><span class="o">/</span><span class="mh">2</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="no">`wrealZstate</span><span class="o">:</span> <span class="no">`wrealXstate</span><span class="p">;</span>

<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">Real numberモデルはデジタルソルバで実行される。</p>
</li>
<li><p class="first">AMSモデルのデジタルブロックは再利用。アナログブロックのみ書き直しとする。</p>
</li>
<li><div class="first line-block">
<div class="line">アナログソルバを含まないため、負荷インピーダンスの影響はモデル化出来ない。</div>
<div class="line">出力は、負荷抵抗を無視した実際の電圧で定義される。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">wrealタイプ(VerilogAMSサポート)：</div>
<div class="line">64bitのreal numberとして認識し、ブロック間のデジタル値として用いられる。</div>
<div class="line">bitやバスとは違い実数として解釈される。</div>
</div>
</li>
</ul>
</div></blockquote>
<div class="section" id="id10">
<h4>端子の属性定義<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>ピンは全てwreal定義</li>
<li>注意：wrealはdisciplineではなく、単なるシグナルタイプ。デフォルトは、logicのdiscipline。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id11">
<h4>内部変数の定義<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>出力抵抗が不要になったのと、値の変化に立ち上がり時間がなくなるためRoutとTrは不要。</li>
<li>Activeはintegerとして定義する必要がなくなり、内部ピンとして定義される。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id12">
<h4>デジタルブロック<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">verilogAMSのデジタルブロックはそのまま。</p>
</li>
<li><p class="first">verilogAMSのアナログブロックをデジタル処理として置き換える。</p>
</li>
<li><div class="first line-block">
<div class="line">veriloaでは、ピンと変数で2つの異なるメカニズムがある。</div>
<div class="line">変数：real, integer又はregで宣言され、always又はinitialブロックで定義される。</div>
<div class="line">ピン：wire(又はwreal)宣言され、wireはassign文によって制御される。</div>
</div>
</li>
<li><p class="first">wire Active=...は、制御のために内部pinとして定義。式の結果が変化した時にActiveの値がアップデートされる。</p>
</li>
<li><div class="first line-block">
<div class="line">alwaysブロックは、コモンモードと最大振幅値計算に使用。</div>
<div class="line">電源又はActiveフラグの変化時に計算される。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Vodiff(出力電圧差)の記述はalwaysブロックで表現。</div>
<div class="line">ただし、この場合は&#64;(*)をブロックに追加する事で、全変数のいずれかが変更された場合に計算されるようにしている。</div>
<div class="line">always &#64;(*)は、always &#64;(Vomax, Av, INP, INN, Active)。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">標準のデジタルピンは出力状態としてX(unkown)とZ(high impedance)をサポートする。</div>
<div class="line">しかし、VerilogAMS言語の仕様はこれらの表現を含まないため、代わりに`wrealXstate、`wrealZstateを使用する。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">出力ピン(OUTP,OUTN)はActiveとEN信号によって制御される。</div>
<div class="line">しかし、Z状態とX状態があるため、直接wreal型のピンにドライブする事ができないのでassign文で記述する。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="digital-pga-model">
<h3>Digital PGA Model<a class="headerlink" href="#digital-pga-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>pga_verilog</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`include</span> <span class="s">&quot;disciplines.vams&quot;</span>

<span class="k">module</span> <span class="no">PGA</span> <span class="p">(</span><span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">,</span> <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">,</span> <span class="no">GAIN</span><span class="p">,</span> <span class="no">VB</span><span class="p">,</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span> <span class="no">EN</span><span class="p">);</span>
<span class="k">output</span> <span class="no">OUTP</span><span class="p">,</span><span class="no">OUTN</span><span class="p">;</span>               <span class="c1">// differential output</span>
<span class="k">input</span>  <span class="no">INP</span><span class="p">,</span><span class="no">INN</span><span class="p">;</span>                 <span class="c1">// differential input</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="no">GAIN</span><span class="p">;</span>               <span class="c1">// digital control bus</span>
<span class="k">input</span> <span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">;</span>               <span class="c1">// power supplies &amp; bias voltage input</span>
<span class="k">input</span> <span class="no">EN</span><span class="p">;</span>                       <span class="c1">// output enable</span>
<span class="c1">// note that all the signals are just digital here - no analog contet.</span>

<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmin</span><span class="o">=-</span><span class="mh">1</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=000</span>
<span class="k">parameter</span> <span class="kt">real</span> <span class="n">dbmax</span><span class="o">=</span><span class="mh">20</span><span class="p">;</span>        <span class="c1">// gain for VCVGA=111</span>
<span class="kt">real</span> <span class="n">DBinc</span><span class="p">,</span> <span class="n">Adb</span><span class="p">,</span> <span class="n">Av</span><span class="p">;</span>            <span class="c1">// terms in gain calculation</span>

<span class="k">initial</span> <span class="n">DBinc</span><span class="o">=</span><span class="p">(</span><span class="n">dbmax</span><span class="o">-</span><span class="n">dbmin</span><span class="p">)</span><span class="o">/</span><span class="mh">7</span><span class="p">;</span>  <span class="c1">// compute per-bit change to db gain</span>
<span class="k">always</span> <span class="k">begin</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">===</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span> <span class="p">)</span> <span class="n">Adb</span><span class="o">=-</span><span class="mh">40</span><span class="p">;</span> <span class="c1">// low gain if invalid control input</span>
  <span class="k">else</span> <span class="n">Adb</span><span class="o">=</span><span class="n">dbmin</span><span class="o">+</span><span class="n">DBinc</span><span class="o">*</span><span class="no">GAIN</span><span class="p">;</span>    <span class="c1">// compute gain in dB</span>
  <span class="n">Av</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span><span class="n">Adb</span><span class="o">/</span><span class="mf">20.0</span><span class="p">);</span>		<span class="c1">// convert to V/V</span>
  <span class="p">@(</span><span class="no">GAIN</span><span class="p">);</span>                      <span class="c1">// recompute on gain bus change</span>
<span class="k">end</span>

<span class="c1">// Check if EN=1, VDD=1, VSS=0, VB=1, and GAIN bits are all valid:</span>
  <span class="kt">wire</span> <span class="n">Active</span> <span class="o">=</span> <span class="p">({</span><span class="no">EN</span><span class="p">,</span><span class="no">VDD</span><span class="p">,</span><span class="no">VSS</span><span class="p">,</span><span class="no">VB</span><span class="p">}</span><span class="o">===</span><span class="mh">4&#39;b1101</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">^</span><span class="no">GAIN</span><span class="p">)</span><span class="o">!==</span><span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">);</span>

<span class="c1">// Pass input to output if active; high impedance when disabled,</span>
<span class="c1">// any other case output goes to invalid:</span>
  <span class="k">assign</span> <span class="no">OUTP</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="no">INP</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bz</span> <span class="o">:</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>
  <span class="k">assign</span> <span class="no">OUTN</span> <span class="o">=</span> <span class="n">Active</span><span class="o">?</span> <span class="no">INN</span> <span class="o">:</span> <span class="o">!</span><span class="no">EN</span><span class="o">?</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bz</span> <span class="o">:</span> <span class="mh">1</span><span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>

<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><div class="first line-block">
<div class="line">純粋なデジタルSimが要求される時や、</div>
<div class="line">アナデジ間のインターフェースをチェックする目的でのみMixed=Signalブロックが含まれる場合に使われる。</div>
</div>
</li>
<li><p class="first">Simにおけるアナログのオペレーションはブラックボックス扱い。</p>
</li>
<li><p class="first">アナログ信号は、H/L信号で表現される。また、受け付けない場合はX、オフした時はZに遷移する。</p>
</li>
<li><p class="first">ブロックの制御特性は内部で計算されるが、それらの値はテストベンチからのダイレクトアクセスか、プロットによる保存によってのみ測定可能。</p>
</li>
<li><div class="first line-block">
<div class="line">デジタルのPGAに対する典型的なアプローチは、</div>
<div class="line">H入力をポジティブ電源(VDD=1)に、L入力をネガティブ電源(VSS=0)にする。</div>
<div class="line">バイアスインプット可能をVB=1とする。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">変換特性は、入力信号を出力信号にそのまま通す。</div>
<div class="line">適切にバイアスされている場合、OUTP=INP, OUTN=INN。</div>
<div class="line">バイアスされていない場合、出力端子はHighインピーダンス(1&#8217;bz)になる。</div>
<div class="line">供給電源が来ていない場合は、unkown状態(1&#8217;bx)となる。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">ゲインはデジタルセグメントとして計算される。</div>
<div class="line">ただし、単なる内部のreal変数であり、変換特性には影響しない。</div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="additional-model-coding-examples">
<h2>Additional Model Coding Examples<a class="headerlink" href="#additional-model-coding-examples" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">このセクションでは以下の四つのモデリングアプローチそれぞれを用いて、Verilog-AMSの代表的なモデルを示す。</div>
</div>
<blockquote>
<div><ul class="simple">
<li>Dフリップフロップのデジタルモデル</li>
<li>オペアンプのアナログモデル</li>
<li>ADコンバータのAMSモデル</li>
<li>離散時間ローパスフィルタのRNモデル</li>
</ul>
</div></blockquote>
<div class="section" id="digital-verilog-d-type-flip-flop">
<h3>Digital: Verilog D-type Flip Flop<a class="headerlink" href="#digital-verilog-d-type-flip-flop" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul>
<li><p class="first">Verilog言語は論理的関係性を定義</p>
</li>
<li><p class="first">ここでは標準Verilogフォーマットによって書かれたD-FFモデルを例に述べる</p>
</li>
<li><div class="first line-block">
<div class="line">この例では入力Clockのエッジを読み込み、出力Qにはデータ入力が読み込まれ通される</div>
<div class="line">出力Qbは常に出力Qの補出力である</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">モデルは非同期リセット式</div>
<div class="line">ResetがhighのときはいつでもQは0になる</div>
</div>
</li>
<li><p class="first">以下にD-FFの簡単な記述を示す</p>
</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="no">DFF1</span> <span class="p">(</span><span class="no">Q</span><span class="p">,</span> <span class="n">Qb</span><span class="p">,</span> <span class="n">Data</span><span class="p">,</span> <span class="n">Clock</span><span class="p">,</span> <span class="n">Reset</span><span class="p">);</span>     <span class="c1">// name of module, list of pins</span>
   <span class="k">output</span> <span class="no">Q</span><span class="p">,</span><span class="n">Qb</span><span class="p">;</span>                              <span class="c1">// nomal and inverted output</span>
   <span class="k">input</span>  <span class="n">Data</span><span class="p">,</span><span class="n">Clock</span><span class="p">,</span><span class="n">Reset</span><span class="p">;</span>                  <span class="c1">// data in, clock, asynch reset</span>
   <span class="kt">reg</span>    <span class="no">Q</span><span class="p">,</span>                                 <span class="c1">// register for output signal to drive</span>
   <span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">Clock</span> <span class="k">or</span> <span class="k">posedge</span> <span class="n">Reset</span><span class="p">)</span>  <span class="c1">// when clock or reset fo high</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Reset</span><span class="p">)</span> <span class="no">Q</span> <span class="o">=</span> <span class="mh">1&#39;b0</span><span class="p">;</span>                   <span class="c1">// if reset is high, output goes zero</span>
      <span class="k">else</span>       <span class="no">Q</span> <span class="o">=</span> <span class="n">Data</span><span class="p">;</span>                   <span class="c1">// otherwise on clock edge get data</span>
   <span class="k">assign</span> <span class="n">Qb</span> <span class="o">=</span> <span class="o">~</span><span class="no">Q</span><span class="p">;</span>                           <span class="c1">// degine notQ output to be inverse of Q</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">Q出力はClockかResetの立上りエッジで更新される</p>
</li>
<li><div class="first line-block">
<div class="line">Qbノードの更新はQ信号の反転と同等の値が連続的に保たたれるように代入文を使用される</div>
<div class="line">動作コードによって駆動していないため、Qbはreg宣言されない</div>
</div>
</li>
<li><p class="first">以下にD-FFの動作をチェックする簡単なテストベンチを示す</p>
</li>
</ul>
<div class="highlight-verilog"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="no">`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ps</span>
<span class="k">module</span> <span class="no">DFF_TB</span><span class="p">;</span>
   <span class="kt">reg</span> <span class="no">D</span><span class="o">=</span><span class="mh">1</span><span class="p">,</span><span class="no">CK</span><span class="o">=</span><span class="mh">0</span><span class="p">,</span><span class="no">RST</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
   <span class="no">DFF1</span> <span class="no">DUT</span><span class="p">(.</span><span class="no">Q</span><span class="p">(</span><span class="no">Q</span><span class="p">),</span> <span class="p">.</span><span class="n">Qb</span><span class="p">(</span><span class="no">QB</span><span class="p">),</span> <span class="p">.</span><span class="n">Data</span><span class="p">(</span><span class="no">D</span><span class="p">),</span> <span class="p">.</span><span class="n">Clock</span><span class="p">(</span><span class="no">CK</span><span class="p">),</span> <span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="no">RST</span><span class="p">));</span>
   <span class="k">always</span> <span class="p">#</span><span class="mh">5</span> <span class="no">CK</span> <span class="o">=</span> <span class="o">~</span><span class="no">CK</span><span class="p">;</span>
   <span class="k">initial</span> <span class="k">begin</span>
      <span class="p">#</span><span class="mh">13</span> <span class="no">D</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">15</span> <span class="no">D</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">10</span> <span class="no">RST</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">10</span> <span class="no">RST</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span>
      <span class="p">#</span><span class="mh">22</span> <span class="nb">$stop</span><span class="p">;</span>
   <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p class="first">DFF_TBは外部ピンが必要とされないシミュレーションのトップレベルのテストベンチモジュール</p>
</li>
<li><p class="first">DFF1モジュールはインスタンスDUTとしてインスタンス化され、Clockへ100MHzのパルス波を打ち込み、そしてDataとResetを数度変化させることで期待通りにブロックが動作するかの検証を行い、モジュールではこれらで駆動する信号とレジスタを定義する</p>
</li>
<li><p class="first">留意すべきは、離散timescaleはこのテストベンチモジュールのために規定されているということである</p>
</li>
<li><div class="first line-block">
<div class="line">すべての離散およびミックスドシグナルのVerilogブロックは、離散時間のためのresolutionとtime unitを定義するために複数のtimescaleを利用する</div>
<div class="line">ここで示したようにモジュールに、標準includeファイル内で、コンパイラオプションで、など定義場所問わない</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">システム内で遅延定義のために#演算子を用いている</div>
<div class="line">モジュール固有の演算子(この場合は#)はここで定義するためにtime unitを必要とする</div>
<div class="line">このケースではtime unitはnsで定義され、#5は5nsを示す</div>
</div>
</li>
<li><p class="first">モジュールがあらゆるところで一貫して定義されるように、プロジェクトのtimescaleとresolutionを定めなければならないことに注意</p>
</li>
<li><p class="first">一般的に、(もっとも一般的に1nsか1psの時間単位)デジタルモデルの標準的な実行と、(システム速度に応じて1nsから1asにわたる)プロジェクト条件に基づいてきまるresolutionによって選ばれる。</p>
</li>
<li><p class="first">DFF1_TBモジュールのシミュレーション波形結果を以下に示す</p>
</li>
</ul>
<div class="figure">
<a class="reference internal image-reference" href="_images/fig4.png"><img alt="_images/fig4.png" src="_images/fig4.png" /></a>
</div>
<ul class="simple">
<li>Qは初期値を設定していないため、Data入力がassignされるClockの最初の立上りエッジまでは不定値(X)であることに注意</li>
<li>DataがHigh/Lowに変化すると、次のClockの立上りエッジでQの値が変化する</li>
<li>ResetがHighになるとすぐにQはLowになり、ResetがHighの間はClockが叩かれてDataの値が変化してもQには影響しない</li>
<li>Resetが解放されると、次のClockの立上りエッジで再びDataの値をQへと伝搬させる</li>
<li>Qbは常にQの反転である</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">Ch.3 AMS Behavioral Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modeling-classifications">Modeling classifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-modeling">Types of Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-moeling-formats">Basic Moeling Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-model-coding-examples">Additional Model Coding Examples</a></li>
</ul>
</li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="index.html" title="Welcome to Mixed-Signal Methodology Guide’s documentation!"
             >previous</a> |
          <a href="genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="_sources/Ch3_AMS_Behavioral_Modeling.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, Team Mixed-Signal Design Automation.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>