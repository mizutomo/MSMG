==============================
Ch.3 AMS Behavioral Modeling
==============================

Overview
====================================

* Analog設計者は、これまでボトムアップ手法により設計を行なってきた。
* 複数のサブシステムを含んだシミュレーションを行うとき、Trレベルでは時間がかかるため、一部ブロック(特性として見る必要のないブロック)をビヘイビアモデルに置き換えるなど、シミュレーションの高速化のためだけに機能モデルを使用してきた。


* このようなボトムアップアプローチは、対処療法的であり、プロジェクトの銀の弾丸ではない。


* システム設計段階から、モデルによりスペックの検証を行うトップダウン設計に移行する必要がある。


* トップダウン・アプローチを取ることで、Executable Spec(検証可能な仕様書)となる。


Modeling classifications
====================================

* アナログの場合、決まった抽象度というものがない。また、デジタルと異なり、モデル開発をサポートするようなツールもほとんどないため、モデル作成にかかる時間が千差万別となる。
* シミュレーション時間も、抽象度によって、大きく異る。
* 効率的なシミュレーションを行うためには、要求に応じた適切な抽象度・複雑度のモデルを用意する必要がある。


* モデリングする際には、以下のことを考慮する必要がある。

  * 対象としているシミュレータがAnalog/Digital/Mixed-Signalを扱えるかどうか。
  * 適切な階層(抽象)構造となっているか。
  * モデルにどこまでの特性を組み込むか。1次の線形特性か、非線形特性か。


* モデル化において重要なことは、モデルの使用目的を把握すること。
* モデルの使用目的が把握できていないと、無駄に抽象度の低いモデルを作ったりしてしまう。


Model Development
-----------------------------------

* モデルの複雑さは、どのレベルであっても要素の数に依存する。

  * もし、ブロックが巨大なピン数を持っていた場合、リーズナブルなレベルまでブレークダウンさせる。
  * ただし、これ以上機能として分割できないようなレベルにまで落とし込むのは、機能モデルとしては適切ではない。


Design Topological Considerations
-----------------------------------

* サブシステムへの分割の仕方は非常に重要である。

* 時には、常識が誤った方向に導くことがある。
* 通常、デジタル回路によって制御されるアナログ回路があった場合、2つのブロックに分けられがちである。
* 上記のように分けてしまうと、アナデジ間の制御信号の抽象度が非常に低くなるだけでなく、2つのモジュールがセットでないと、検証ができなくなる。
* モジュールを一つにして、ブロック(always?)で分割するのがよい。


Types of Modeling
====================================

* 一般的に、大規模システムの検証に用いられる抽象度のレベルとしては、下記のものがあり、用途・目的に応じて、適切な使い分けが必要。

  * Device based design(Spectre, SPICE): 回路図から生成されたネットリスト、もしくは、Pure SPICEで解釈可能なマクロモデルで記述されたネットリスト。

  * Analog modeling(Verilog-A): 電流/電圧の関係式を記述したモデル。アナログソルバ(SPICE)で解かれる。

  * Mixed-signal modeling(Verilog-AMS, VHDL-AMS): アナログ動作とデジタル動作が同時に記述可能なレベル。

  * Discrete real number modeling(Verilog-AMS, VHDL, SystemVerilog): 電気的な動作を実数の信号レベルに置き換えたモデル。インピーダンス効果(電流・電圧の関係式)は無視され、デジタルソルバで解かれる。

  * Logic modeling(Verilog, VHDL, SystemVerilog): 0,1,X,Zでモデリング。


Discrete Digital Modeling
-----------------------------------

* デジタルの入出力関係だけが記述されたモデル。デジタルソルバで解析。アナログ要素は含まない。

* Verilog, VHDL, SystemVerilogで記述が可能。

* アナログIPでもデジタルの入出力のみに着眼して、本レベルで記述されることがある。


Continuous Analog Modeling
-----------------------------------

* システムの電気的特性が記述。言語は、Verilog-A。

* 電圧/電流の関係が記述。また、積分・微分オペレータも使用可能。

* Verilog-Aモデルは、非線形常微分方程式に変換。他のSPICEコンポーネントと同様の方法でSPICEソルバにより解析。

* Trレベルと比較して、10～50倍の高速化が可能。シミュレーションのスピードアップのためには、ノード数の削減と方程式数の削減が鍵。また、弱い非線型モデルにすることで、タイムステップを伸ばすことが可能。

* デジタルの記述は全て電気的特性に変換され、SPICEソルバで実行される。そのため、論理シミュレータで解くよりも低速になる。また、IPCを用いたCo-Simで解析することも可能であるが、解析速度はアナログシミュレータのタイプステップに律速される。


Mixed-Signal Modeling
-----------------------------------

* Mixed-Signalに対応したシミュレータは、1つのカーネルで離散的なデジタル回路と連続的なアナログ回路を解くことができる。

* Verilog-AMS, VHDL-AMSが記述に用いられる。

* AMSでは、デジタルとアナログを自然にそれぞれの抽象度で記述することができる。また、データとイベントは相互に通信可能。


Real Number Modeling
-----------------------------------

* 電気的な信号を実数としてモデル化する手法。実数信号は、電圧もしくは電流のどちらかを表現するのに使用される。

* RNMは、Verilog-AMS, SystemVerilog, VHDLで使用可能。

* RNMは、デジタルソルバのみで解かれるため、SPICEと比べて1000～100万倍の高速化が可能。

* 双方向的なアナログの相関関係をモデリングすることはできない。


Combined Approaches
-----------------------------------

* 実際には、上記の抽象度のレベルを混ぜて使用されることが多い。

* 例えば、RFレシーバの場合、下記の抽象度が混在で使用される。

    * RF信号パス: RNM
    * ベースバンド, バイアス、パワー供給: Electrical
    * 制御回路: ロジック


Basic Moeling Formats
====================================

| この本の目的は、4タイプの記述方法における長所・短所に対する洞察力をつけること。
| 各記述方法における例(Programable-Gain Amplifier)を例に述べていく。


Model Operational Description
------------------------------------------------

* 差動入力、差動出力。出力には入力をゲイン倍した電圧が出力される。
* ゲインは、デジタルの3bitバス入力(GAIN[2:0])。
* 実際のPGAにあるその他のピン(電源、バイアス入力、出力のEnable信号)あり。
* 出力は、(VDD-VSS)/2を中心とする。
* 出力端子の出力抵抗はRoutとする。

 .. csv-table:: List of terminals
    :header: "pinName","expression"
    :widths: 20,70

    "INP,INM","差動入力 V(INP,INM)"
    "OUTP,OUTN","差動出力 V(OUTP,OUTN)"
    "GAIN[2:0]","ゲイン制御端子( dbmin@GAIN=000, dbmax@GAIN=111 )"
    "VDD,VSS","電源"
    "VB","バイアス入力"
    "EN","Enable信号( ハイインピーダンス@EN=0, 通常出力@EN=1 )"


AMS Programmable-Gain Amplifier Model
---------------------------------------------------

  * pga_verilogams

  .. literalinclude:: ./txt/pga_verilogams.txt
    :linenos:
    :language: verilog


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * deciplines.vamsを定義 (/common/appl/Cadence/mmsim/12.1_isr2/linux/tools.lnx86/spectre/etc/ahdl/deciplines.vams)
    * アナログ信号(入出力、電源、バイアス入力)は、electricalで定義。analogブロック内で使われI(),V()を使用して測定。アナログソルバで解かれる。
    * デジタル信号(GAIN,EN)は、logicで定義。デジタルブロック内で使われ、1,0,X,Zの値を持つ。デジタルソルバで解かれる。

パラメータ定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * 定義した数値はデフォルトで、後から変更可能。
    * Trは、スペックではない。ただし、ゲインとコンダクタを変える場合にランプ的に変更するのに使用する。設定しないと、アナログソルバでtime step errorが発生します。

内部変数定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * realとintegerは内部変数。
    * アナログブロックでもデジタルブロックでもどちらでも使用できるが、どちらか一方でしかアクセス出来ない。
    * アナログの場合はanalogブロック内でアップデートされ、デジタルの場合はinitialかalwaysブロック内でアップデートされる。

デジタルブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    1. initial文: Simulationの最初で計算される。

      * DBinc(GAINの1bit辺りのゲイン増加両)を計算。

    2. always文: Sim中繰り返し計算される。

      * GAINの各Bitをexclusive-ORする事で、入力信号にXが含まれるかを確認する。
      * GAIN[2:0]にXが含まれる場合はAdb=-40を設定、含まれない場合は、Adb= dbmin+DBinc*GAINでゲインを計算。
      * @(GAIN)が重要。これを入れることによって、always文の解析が次のGAIN信号が変化した時に評価されるようになる。これが無かったら、解析時間は0[sec]で止まってしまい永久ループとなってしまう。



アナログブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | Activeフラグは、EN信号と電源電圧、バイアス電圧で決定。
      | 電源電圧≧2.0[V]、バイアス電圧=0.7±0.05V[V]。
    * | Avは、Adb(ゲイン)をdBから比率に変更したもの。
      | Active=1の時に計算結果、Active=0の時は0.001とする。
      | Adbの急激な変化によるtime step errorを防ぐためにtransition関数で立ち上がりにTrの時間を設けている。
    * | Voctrは、コモン電圧で電源電圧の1/2。ただし、電源・バイアスを満たさない場合には供給されないため、Active信号で制御。
      | Active信号は急峻に変化するため、transition関数で立ち上がりにTrの時間を設けている。
    * | Vomaxは、出力のpeak-to-peakの最大出力のため電源電圧で定義。ただし、電源電圧が供給されていない場合には、0.001[V]とする。
    * | Vodifは、差動出力の信号成分。
      | 入力差動信号をゲイン倍したものになるが、AMPの動作電圧で飽和する。
      | min/maxで簡単に定義する事も出来るが、実回路特性に近づけるためtanh(ハイパーボリックタンジェント)関数を使用して緩やかにリミットがかかるようにした。

    .. image::  ./img/vodif.png
       :alt: Inputとoutputの関係

    * | Goutは、出力コンダクタンス。
      | EN=1の場合は1/Routだが、EN=0の場合は1/1GΩとなる。ENの2値の切換えにはtransition関数を使用する。
      | (100Ωから0.1%の変化で1MΩに到達するためEN信号による切換えは直ぐに行われる。)
    * | 出力端子の電流/電圧の関係を示す。コントリビューション文(<+)を使用する事で、分岐点における電流と電圧の関係をノード解析によって求める。
      | 出力電圧だけであれば、V(OUTP,VSS)<+Voctr+Vodif/2;で示せるが、コンダクタンスを式に加える事で電流成分も表す。


Analog PGA Model
-----------------------------------------

  * pga_veriloga

  .. literalinclude:: ./txt/pga_veriloga.txt
    :linenos:
    :language: verilog

  * アナログモデルは、デジタルソルバが無い場合、又は全PINがアナログ端子として定義されている場合に使用され、VerilogAで記述される。
  * verilogAを使用(VerilogAMSの一部)
  * verilogAMSで示したアナログブロックと同じ物を使用できる。ただし、デジタル部は存在しない。


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | 全ピンはelectrical又はその他の連続系で定義される。（熱、磁力、一方向or循環システム等）
      | ENとGAINがelectrical宣言されるのだけVerilogAMSと違い、他は同じ。

    * | 離散数(値)は時間で変化する電圧波形としてモデル化⇒シミュレーション速度が遅くなる。
      | 各デジタル信号のH→L変化にtransition波形を使用するため、多くの解析ステップが必要で通常はシミュレーションスピードが遅くなる。
      | 本モデルでは、GAINはまれにしか動かないので、スピード的には問題にならない。


内部変数定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * VerilogAMSとほぼ同じ。ただし、全てアナログブロック内で使用。
    * [追加]Gint：GAINバス入力からinteger(0～7)の値を求めるのに使用。


マクロの追加
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * デジタルノードの電圧を変換するためのマクロ(\`L())を追加
    * | アナログブロックで、1/2電源電圧をスレッショルドとしてデジタル信号を処理、
      | 条件分岐はTrueで1、falseで0を返す。

    * マクロ定義する事で、複数個所の同じ処理を簡易化（コンパイル時の影響はなし）。
    * | 例えば、EN信号のロジックレベル判定を`L(EN)と書く事で、V(EN,VSS)>V(VDD,VSS)/2の結果に置換える。
      | Activeフラグも同じ。

    * デジタルブロックで定義されていたTrue/False判定は複数個所で実行されていたためマクロ化した。


アナログブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * | @(initial_step)は、アナログシミュレーションの初期ステップで評価を実施する(デジタルinitialと同じ)。
      | DBincをアナログブロック内で初期化するのに使用。
    * GAINバスは、electricalノードから`L()マクロを使ってロジックレベルを検知し、0～7のintegerを返す。
    * Adb(dbゲイン)はGintを元に計算され、Av(比率ゲイン)はAMSの場合と同じ評価式で計算される。
    * 残りのコードは、EN信号のロジックレベル判定以外はAMSと同じ。


Real PGA Model
------------------------------------------

  *  pga_wrealmodel

  .. literalinclude:: ./txt/pga_realmodel.txt
    :linenos:
    :language: verilog

  * Real numberモデルはデジタルソルバで実行される。
  * AMSモデルのデジタルブロックは再利用。アナログブロックのみ書き直しとする。

  * | アナログソルバを含まないため、負荷インピーダンスの影響はモデル化出来ない。
    | 出力は、負荷抵抗を無視した実際の電圧で定義される。

  * | wrealタイプ(VerilogAMSサポート)：
    | 64bitのreal numberとして認識し、ブロック間のデジタル値として用いられる。
    | bitやバスとは違い実数として解釈される。


端子の属性定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * ピンは全てwreal定義
    * 注意：wrealはdisciplineではなく、単なるシグナルタイプ。デフォルトは、logicのdiscipline。


内部変数の定義
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * 出力抵抗が不要になったのと、値の変化に立ち上がり時間がなくなるためRoutとTrは不要。
    * Activeはintegerとして定義する必要がなくなり、内部ピンとして定義される。


デジタルブロック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    * verilogAMSのデジタルブロックはそのまま。
    * verilogAMSのアナログブロックをデジタル処理として置き換える。

    * | veriloaでは、ピンと変数で2つの異なるメカニズムがある。
      | 変数：real, integer又はregで宣言され、always又はinitialブロックで定義される。
      | ピン：wire(又はwreal)宣言され、wireはassign文によって制御される。

    * wire Active=...は、制御のために内部pinとして定義。式の結果が変化した時にActiveの値がアップデートされる。

    * | alwaysブロックは、コモンモードと最大振幅値計算に使用。
      | 電源又はActiveフラグの変化時に計算される。

    * | Vodiff(出力電圧差)の記述はalwaysブロックで表現。
      | ただし、この場合は@(*)をブロックに追加する事で、全変数のいずれかが変更された場合に計算されるようにしている。
      | always @(*)は、always @(Vomax, Av, INP, INN, Active)。

    * | 標準のデジタルピンは出力状態としてX(unkown)とZ(high impedance)をサポートする。
      | しかし、VerilogAMS言語の仕様はこれらの表現を含まないため、代わりに\`wrealXstate、\`wrealZstateを使用する。

    * | 出力ピン(OUTP,OUTN)はActiveとEN信号によって制御される。
      | しかし、Z状態とX状態があるため、直接wreal型のピンにドライブする事ができないのでassign文で記述する。


Digital PGA Model
------------------------------------------


  * pga_verilog

  .. literalinclude:: ./txt/pga_verilog.txt
    :linenos:
    :language: verilog

  * | 純粋なデジタルSimが要求される時や、
    | アナデジ間のインターフェースをチェックする目的でのみMixed=Signalブロックが含まれる場合に使われる。

  * Simにおけるアナログのオペレーションはブラックボックス扱い。
  * アナログ信号は、H/L信号で表現される。また、受け付けない場合はX、オフした時はZに遷移する。
  * ブロックの制御特性は内部で計算されるが、それらの値はテストベンチからのダイレクトアクセスか、プロットによる保存によってのみ測定可能。

  * | デジタルのPGAに対する典型的なアプローチは、
    | H入力をポジティブ電源(VDD=1)に、L入力をネガティブ電源(VSS=0)にする。
    | バイアスインプット可能をVB=1とする。

  * | 変換特性は、入力信号を出力信号にそのまま通す。
    | 適切にバイアスされている場合、OUTP=INP, OUTN=INN。
    | バイアスされていない場合、出力端子はHighインピーダンス(1'bz)になる。
    | 供給電源が来ていない場合は、unkown状態(1'bx)となる。

  * | ゲインはデジタルセグメントとして計算される。
    | ただし、単なる内部のreal変数であり、変換特性には影響しない。


Additional Model Coding Examples
====================================

| このセクションでは以下の四つのモデリングアプローチそれぞれを用いて、Verilog-AMSの代表的なモデルを示す。

  * Dフリップフロップのデジタルモデル
  * オペアンプのアナログモデル
  * ADコンバータのAMSモデル
  * 離散時間ローパスフィルタのRNモデル


Digital: Verilog D-type Flip Flop
------------------------------------------------

  *   Verilog言語は論理的関係性を定義
  *   ここでは標準Verilogフォーマットによって書かれたD-FFモデルを例に述べる
  * | この例では入力Clockのエッジを読み込み、出力Qにはデータ入力が読み込まれ通される
    | 出力Qbは常に出力Qの補出力である
  * | モデルは非同期リセット式
    | ResetがhighのときはいつでもQは0になる
  *   以下にD-FFの簡単な記述を示す

  .. literalinclude :: ./txt/d_ff.v
    :linenos:
    :language: verilog
    :lines: 1-9

  *   Q出力はClockかResetの立上りエッジで更新される
  * | Qbノードの更新はQ信号の反転と同等の値が連続的に保たたれるように代入文を使用される
    | 動作コードによって駆動していないため、Qbはreg宣言されない
  *   以下にD-FFの動作をチェックする簡単なテストベンチを示す

  .. literalinclude :: ./txt/DFF_TB.v
    :linenos:
    :language: verilog
    :lines: 1-13

  *   DFF_TBは外部ピンが必要とされないシミュレーションのトップレベルのテストベンチモジュール
  *   DFF1モジュールはインスタンスDUTとしてインスタンス化され、Clockへ100MHzのパルス波を打ち込み、そしてDataとResetを数度変化させることで期待通りにブロックが動作するかの検証を行い、モジュールではこれらで駆動する信号とレジスタを定義する

  *   留意すべきは、離散timescaleはこのテストベンチモジュールのために規定されているということである
  * | すべての離散およびミックスドシグナルのVerilogブロックは、離散時間のためのresolutionとtime unitを定義するために複数のtimescaleを利用する
    | ここで示したようにモジュールに、標準includeファイル内で、コンパイラオプションで、など定義場所問わない
  * | システム内で遅延定義のために#演算子を用いている
    | モジュール固有の演算子(この場合は#)はここで定義するためにtime unitを必要とする
    | このケースではtime unitはnsで定義され、#5は5nsを示す
  *   モジュールがあらゆるところで一貫して定義されるように、プロジェクトのtimescaleとresolutionを定めなければならないことに注意
  *   一般的に、(もっとも一般的に1nsか1psの時間単位)デジタルモデルの標準的な実行と、(システム速度に応じて1nsから1asにわたる)プロジェクト条件に基づいてきまるresolutionによって選ばれる。

  *   DFF1_TBモジュールのシミュレーション波形結果を以下に示す

  .. figure:: ./img/fig4.png
    :scale: 75%

  *   Qは初期値を設定していないため、Data入力がassignされるClockの最初の立上りエッジまでは不定値(X)であることに注意
  *   DataがHigh/Lowに変化すると、次のClockの立上りエッジでQの値が変化する
  *   ResetがHighになるとすぐにQはLowになり、ResetがHighの間はClockが叩かれてDataの値が変化してもQには影響しない
  *   Resetが解放されると、次のClockの立上りエッジで再びDataの値をQへと伝搬させる
  *   Qbは常にQの反転である


Analog: Verlog-A Operational Amplifier
------------------------------------------------

このセクションでは、Verilog-Aの例として、OpAmpを解説。

  * アナログビヘイビアモデルの設計は、ピンの入力と出力の電圧・電流の関係(線形性、非線形性、積分関係、微分関係)に着目して、モデリングを行う。

  * また、入出力のピンだけでなく、内部変数を用いて、時間依存の関係は、離散的なイベントの処理を行い、出力信号は、入力信号値や内部変数値の関係で記述される。


  * 単一の特性だけでなく、一つのモデルで複数の特性を表現することがある。

  * ここでは、以下の特性を持ったアンプのモデルを例として説明する。

    * DCゲイン
    * オフセット
    * クリッピング
    * 出力インピーダンス
    * ポールの周波数特性


  * このようなモデルを開発する際には、先に等価回路を導く必要がある。その後、そのトポロジをモデルに書き下す。

  * オペアンプの等価回路を下記図に示す。

    .. figure:: ./img/opamp_circuit.png
      :scale: 75%

    * Icur: 入力差(inp, inm)に応じて、電流値を出力する電圧制御電流源(VCCS)。出力段をドライブする。Icurは、Rresに流れ、DCゲインを生成する。
    * Vctr: 入力差が0の場合、電圧源Vctrが、DC出力電圧を電源電圧の中間値になるように調整する。
    * Ccap: ポール位置の調整をするための容量。
    * Ilim: 非線形電流源。内部ノードNが供給電源以上にならないように、電流をシャントする。ダイオードによるリミッタの働き。
    * Rout: 付加的な出力抵抗。DC的には、出力抵抗は、RoutとRresの合成抵抗となるが、AC的には、容量CcapとIlimによる低インピーダンスの経路の存在により、ノードNがほぼグラウンドにショートされる。そのため、出力抵抗は、Routとなる。

  .. literalinclude:: ./txt/Amp1.va
    :linenos:
    :language: verilog


  * モデルの正しさを検証するために、テストベンチを作成する。

  * Verilog-Aモデルの場合、回路図作成環境でテストベンチを作成し、様々な条件下でいくつかのシミュレーションを実行する。

  * アンプの場合、閉ループ特性、開ループ特性、線形動作領域、飽和動作領域の検証をDC/AC/Tran解析を用いて行う。

  * 下図にテストベンチを示す。このテストベンチでは、フィードバック抵抗をR1, RFでパラメータ化しており、このパラメータ値を調整することで、開ループ/閉ループを切り替える。

    .. figure:: ./img/opamp_testbench.png
      :scale: 75%


  * DCスイープシミュレーションの結果を下図に示す。この解析では、特に、線形領域と飽和領域の連続性を検証することができる。また、閉ループ特性を検証することで、フィードバックループが存在している場合のモデルの収束性を検証することもできる。

    .. figure:: ./img/opamp_dc.png
      :scale: 75%


  * AC解析は、周波数応答を検証するために使用される。

  * 開ループ特性では、小信号ゲイン、コーナー周波数、位相の関係を検証することができる。

  * 閉ループ特性では、フィードバックループに依り、ゲイン特性と位相特性が望ましい値になっているかを検証できる。

    .. figure:: ./img/opamp_ac.png
      :scale: 75%

    * テキスト通りの開ループ特性を得るためには、リミッタ電流源を無効にしなければいけなかった。


  * Tran解析では、ステップ入力をアンプに加えることで、線形性と非線形性の直接の関係を見ることができる。

    .. figure:: ./img/opamp_tran.png
      :scale: 75%

  * 上記の例では、±100mVをゲイン1の設定に対して、加えた場合、出力は完全に入力に追随している。

  * ゲインを10に設定した場合、出力は10倍になるが、応答はそれほど速くはならない。また、開ループの応答は、決まったスリューレートに制約されているが、電源電圧付近に達すると飽和してしまう。


  * テストベンチを回路図で書くことが、ベストか?

  * Verilog-A/Verilog-AMSのネットを使用して、テストシーケンスをファイルに書き、また、特性の測定も記述することができる。

  * AC解析と同じ結果を見るためには、回路をsin波でドライブし、出力の振幅と波形のズレを観測すればよい。この方法により、シミュレーション時間は増大するが、再利用性が高まる。

  * テストベンチをテキストで書くことで、多数の条件を一度のシミュレーションで実行し、かつ、結果のインスペクションが可能となる。



Mixed-signal: Verilog-AMS Digital to Analog Converter
--------------------------------------------------------

* A digital to analog converter(DAC)の記述

* 本モデルの第一の入力はデジタルのバス入力である

* 入力が変化すると、出力電圧は参照電圧の比率として計算された電圧となる

* 離散信号によって制御されたアナログ出力を定義するときは注意が必要

* アナログ出力がある値から別の値へ離散的な変化をするならば、重大な数の問題が起き、シミュレーションがスローダウンするか、収束エラーが起きる

* 離散的に変化する量は、階段変化をランプ波形等の連続波形に変換しなければならない。

* 本モデルでは離散的な変化に対しtransition filterを適用する

* デジタル入力の有効性(不定値)がチェックされなければならない。

* 本モデルではイリーガルなバス値のときに出力電圧を0としている

  .. literalinclude:: ./txt/dac.vams
    :linenos:
    :language: verilog

* DACテストのテストベンチはVerilog-AMSでシンプルに記述される

* ひとつのinitialブロック内に離散値とアナログのスティミュラスを記述し、
  シーケンシャルな変数リストと、次の値へ変化するまでの時間とで構成される

* 最後の数行に、入力が無効になったときと供給電圧値が変化したときの出力テストがある

* これはブロックレベルでのビヘイビアモデル検証で含むべき標準的なチェックである

* 典型的な入力だけでなく、期待されない入力時のモデルのファンクションを適切にチェックできる


  .. literalinclude:: ./txt/dac_tb.vams
    :linenos:
    :language: verilog


  .. figure:: ./img/DAC6_TB.png
    :scale: 50%


* より洗練されたモデルにおいては、バイアス入力の要求仕様、非線形性 and/or デジアナ変換時のランダムオフセット等の特性も含めるべきである。

* これにはより包括的なテストベンチが必要で、特定の入力信号を生成、出力波形を取得、要求された特性の計算を行うテストベンチが必要である

* Verilog-AMSは、これらを自然に記述することができる

* 推奨される方法は、特定のテストと出力がスペックを満足しているかのレポートを、taskで定義することである

* 例えば、デジタル入力に特定の値を入れ、出力値が正しいかどうかをチェックようにtaskを定義する

* taskの動作

  1. Dinに特定の値を入れる。
  2. 出力が反応するまでの特定時間待つ。
  3. 出力期待値を計算する。
  4. 実際の出力と期待される出力を比較し、スペック外であればメッセージを出力する。
  5. テストのpassとfailの数をカウントする。

* 以下、上記動作の記述を示す。各入力値において出力が期待値の1%以内かをチェックする。


  .. literalinclude:: ./txt/d2acheck.v
    :linenos:
    :language: verilog


* taskを利用して、特定コードのチェック、適切な動作検証のためのテスト手順を記述することができる。


  .. literalinclude:: ./txt/dac_tb2.vams
    :linenos:
    :language: verilog


  .. figure:: ./img/DAC6_TB2.png
    :scale: 50%


* このようなテストは仕様変更による繰り返しテストを行うときに特に役立つ

* テストベンチはモデルが定義された仕様を満足するかテストされているかどうかをレポートする。

* 同じテストベンチをトランジスタレベルのテストでも使用でき、各viewが定義された精度内で仕様にマッチするか検証できる。

* 検証手順のコード開発に多くの時間がかかるとしても、このアプローチは検証プロセスの自動化にを助けることができる。

* アナログとMixed-Signalの検証プロセスにおいて、一度このような手順を標準的に実行すれば、すぐにシステムレベル検証手順の用途に適用することができる。


Real Number Modeling
--------------------------------------------------------

  * RNMでは、アナログの電圧値は、時間変動の実数シーケンスとして表現される。実際には、これはアナログシミュレータが行っていることと同じである。アナログシミュレータとの違いは、モデルが方程式として定義されているかどうか、という点である。回路シミュレータは、回路トポロジからキルヒホッフの法則に基づき、方程式を作り、その方程式を各タイムステップで全体を満たすように解き、電圧・電流を求める。それに対して、離散システムでは、電圧対電流の関係式はなく、また、キルヒホッフの法則も、方程式を同時に解かないといけない、という制約もない。電流の効果やフィードバック機構の影響を無視(これにより、ドライバと負荷の間の相互関係はなくなる)した入力から、出力を直接計算するだけである。

  * これは、抽象的すぎる計算モデルであり、トランジスタレベルのシミュレーションとはかけ離れたものである。しかしながら、トランジスタレベルよりも遥かに高い抽象度でシステムを記述することで、システム全体の関係を記述することができる。入力が変動した場合、信号は回路ブロック(例えば、比較回路、スケール回路、変換回路、フィルタ、遅延回路、スリュー回路など)により処理され、出力信号が生成される。このようなRNMのコンセプトは、システムの検証だけではなく、探索にも使用できる。トランジスタレベルでサブシステムを検証し、その後、そのブロックのビヘイビアモデルを使用して、システムを高抽象度で検証するのは、もはや常識である。また、AMSモデリング技術ではなく、実数技術を用いて、ビヘイビアモデルを作成することは、前述の自然な拡張であり、システムレベルの検証において、スループットを高めることができる。

  * 実数モデルのコンセプトは、簡単なものである。もし、入力/出力の関係が伝達関係にあるならば、入力が変化した時に、出力が更新されるという関係を数式で記述すればよい。固定電圧(バイアス、電源など)の場合も単純である。電源電圧や、バイアス電流、電圧入力は、実数値としてモデル化される。シミュレータは、それらが適切な許容範囲であるか、出力が適切なバイアスで制御されているかどうかチェックする。これらの動作は、PGAの例で既に記述したとおりである。

  * 実数モデルで、時間変動の波形を表現するためには、もう少しやるべきことがある。アナログ記述言語では、立ち上がり時間を指定したり、スリュー、積分、微分などのアナログフィルタはビルトインとして用意されているのに対して、実数モデリングでは、このような関数は自動的に使用することができない。代わりに、離散システムでシステムを記述する必要がある。大抵の効果は数行で書くことができるが、いささか経験が必要となる。もし、実数モデルを始めるならば、最初にこのような関数をライブラリ化しておくことをお勧めする。これによって、経験の無さを補うことができるだけでなく、効果的に利用することができる。一度このような伝達関数の変換を経験すると、今後、アナログ特性を離散モデルに変換するのに役に立つであろう。

  * アナログシステムでは、積分動作はよく使用される。離散システムでは、入力は時系列のデータとして与えられ、出力は入力の過去の値と現在の値から、台形積分法を用いて計算される。

      OUT_new = OUT_old + (T_new - T_old)*(IN_new + IN_old)/2

    つまり、入力が変化した場合、新しい出力(OUT_new)は、T_new, IN_newから求めることができる。


Verilog-AMS/wreal Low-pass Filter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  * ローパスフィルタは、離散システムの時間応答の定式化に非常に役に立つ例である。アナログドメインでは、フィルタ特性は、ポールとゼロ点を持つ多項式として記述される(H(s)=N(s)/D(s))。このラプラス形式の表現は、周波数領域ではよく機能し、また、RLC回路に簡単にマッピングできる。しかし、イベントドリブンな離散システムでは、この形式は抽象的過ぎる。離散システムでは、フィルタ特性はZ領域で記述される。Z領域では、出力は、入力の項と、遅延された入力の項で表現される。

  * H(s)からH(z)に変換する方法には、標準的なものがある。

  * 例として、1次のローパスフィルタを考える。周波数領域では、以下の伝達関数で与えられる。

      H(s) = OUT / IN = 1 / (1 + s/Wp)
        Wp: コーナー周波数[rad/sec]

    H(s)からH(z)の変換には、以下の双一次変換(Bilinear Transform)を用いて、変換することができる。

      s = (2/Ts) * (1-z^(-1)) / (1+z^(-1))
        Ts: サンプリングレート, z^(-1): 単に遅延素子

    これをs領域の伝達関数に適用すると、

      H(z) = 1 / (a + (2/WpTs)(1-z^(-1))/(1+z^(-1)))

    (1+z^(-1))を分母・分子にかけると

      H(z) = (1 + z^(-1)) / (1 + 2/WpTs + (1 - 2/WpTs)z^(-1)) = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))

    ここで、

      n0 = 1, n1 = 1, d0 = 1 + 2/WpTs, d1 = 1 - 2WpTs

    である。次に、結果の差分式を計算する式をコードに落とし込む。

      H(z) = OUT / IN = (n0 + n1*z^(-1)) / (d0 + d1*z^(-1))

    INとOUTの関係を導くために、式を変形する。

      OUT * (d0 + d1*z^(-1)) = IN * (n0 + n1*z^(-1))

    OUTについて解く(z^(-1)は、遅延単位素子であることを思い出す)。

      OUT = (n0*IN + n1*z^(-1)*IN - d1*z^(-1)*OUT) / d0

    最後に、z^(-1)を過去の値に置き換えることで、望ましい式を得ることができる。

      OUT_new = (IN_new * n0 + IN_old * n1 - OUT_old * d1) / d0

    ローパスフィルタのVerilog-AMS/wrealのコードを以下に示す。

      .. literalinclude:: ./txt/lpf1s.v
        :linenos:
        :language: verilog

  * 上記のモデルが正しく動いているかは、ステップ入力を与えた時に出力が適切な時定数で動いているかどうかで検証することができる。3つのローパスフィルタ(それぞれ、異なるコーナー周波数を設定)を配置し、ステップ入力を与えるテストベンチと波形を以下に示す。

      .. literalinclude:: ./txt/lpf1s_tb.v
        :linenos:
        :language: verilog


      .. figure:: ./img/LPF_WREAL.png
        :scale: 75%


